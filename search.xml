<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis持久化AOF</title>
      <link href="/2024/06/14/2024-06-2024-06-14-redis-chi-jiu-hua-aof/"/>
      <url>/2024/06/14/2024-06-2024-06-14-redis-chi-jiu-hua-aof/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化AOF"><a href="#Redis持久化AOF" class="headerlink" title="Redis持久化AOF"></a>Redis持久化AOF</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以aof为后缀的文件，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><p><img src="/img/example-20201228191729756.png" alt="原理"></p><h2 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h2><p>Redis默认不开启AOF持久化方式，需要在配置文件中开启并进行更详细的配置。</p><pre class=" language-redis"><code class="language-redis"># 开启aof机制appendonly yes# aof文件名appendfilename "appendonly.aof"# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或noappendfsync always# 默认不重写aof文件no-appendfsync-on-rewrite no# 保存目录dir ~/redis/</code></pre><h3 id="重要配置项说明"><a href="#重要配置项说明" class="headerlink" title="重要配置项说明"></a>重要配置项说明</h3><h4 id="appendfsync-写入策略"><a href="#appendfsync-写入策略" class="headerlink" title="appendfsync 写入策略"></a>appendfsync 写入策略</h4><p>我们可以通过<code>appendfsync</code>选项来指定写入策略，有以下三个选项。</p><ul><li><strong>always</strong><br>客户端的每一个写操作都保存到aof文件中，这种策略很安全，但是每个写操作都有io，所以比较慢。</li><li><strong>everysec</strong><br><code>appendfsync</code> 的默认写入策略，每秒写入一次aof文件，因此最多可能丢失1s的数据。</li><li><strong>no</strong><br>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</li></ul><h4 id="no-appendfsync-on-rewrite-aof文件重写"><a href="#no-appendfsync-on-rewrite-aof文件重写" class="headerlink" title="no-appendfsync-on-rewrite aof文件重写"></a>no-appendfsync-on-rewrite aof文件重写</h4><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候aof保存每一次命令到aof中，文件将会变得非常大。</p><p>aof文件大，那么加载aof文件恢复数据时就会非常慢。为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集。</p><h3 id="aof文件损坏"><a href="#aof文件损坏" class="headerlink" title="aof文件损坏"></a>aof文件损坏</h3><p>在写入aof日志文件时，如果Redis服务器宕机，则aof文件会出现格式错误，在重启Redis时，Redis服务器会拒绝载入这个aof文件，可以通过一下步骤修复aof文件</p><ol><li>备份现在的aof文件</li><li>使用redis-check-aof命令修复aof文件<pre class=" language-shell"><code class="language-shell">$ redis-check-aof -fix file.aof</code></pre></li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>AOF只是追加日志文件，所以对服务器性能影响较小，速度比RDB要快，消耗的内存也小。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>AOF生成的日志文件太大，即时通过重写，体积仍然很大。</li><li>恢复数据的速度比RDB慢。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化RDB</title>
      <link href="/2024/06/13/2024-06-2024-06-13-redis-chi-jiu-hua-rdb/"/>
      <url>/2024/06/13/2024-06-2024-06-13-redis-chi-jiu-hua-rdb/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化RDB"><a href="#Redis持久化RDB" class="headerlink" title="Redis持久化RDB"></a>Redis持久化RDB</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Redis作为一个键值对内存数据库（NoSQL），数据都存储在内存中，在处理客户端请求时，所有操作都在内存当中进行。</p><p>但是存储在内存中的数据，只要服务器关机（各种原因引起的），内存中的数据就会消失了，不仅服务器关机会造成数据消失，Redis服务器守护进程退出，内存中的数据也一样会消失。</p><p>对于只把redis当做缓存来用的项目，数据消失问题不大，重新把数据加载进来即可，但如果直接把业务数据存储在redis中，把redis作为数据库来使用，在其存储重要业务数据，那么Redis的内存数据丢失所造成的影响也许是毁灭性的。</p><p>为了避免内存中数据丢失，Redis提供了对持久化的支持，接下来介绍一下持久化方案之一RDB。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB是一种快照存储持久化方式，具体就是讲redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名是dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件中的数据导内存中</p><h3 id="开启RDB"><a href="#开启RDB" class="headerlink" title="开启RDB"></a>开启RDB</h3><ul><li><code>save</code>命令<br>save命令是一个同步操作<br><img src="/img/example-20201228185301914.png" alt="原理"></li></ul><p>当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。</p><blockquote><p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令。</p></blockquote><ul><li><code>bgsave</code>命令<br>bgsave是一个异步操作<br><img src="/img/example-20201228185431285.png" alt="原理"></li></ul><p>当客户端发出bgsave命令时，Redis服务器主进程会forks一个子进程来同步数据，在数据保存到rdb文件之后，子进程将会退出。</p><p>所以与save命令相比，Redis服务器在处理bgsave采用子进程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着如果forks一个子进程花费的时间太久，仍然会有阻塞其他客户端请求的情况发生。</p><ul><li>配置文件<br>除了通过客户端发送命令外，还有一种方式，就是在redis配置文件中的save指定到达触发RDB持久化条件。<pre class=" language-redis"><code class="language-redis"># 900s内至少达到一条写命令save 900 1# 300s内至少达至10条写命令save 300 10# 60s内至少达到10000条写命令save 60 10000</code></pre></li></ul><p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p><h3 id="rdb的优缺点"><a href="#rdb的优缺点" class="headerlink" title="rdb的优缺点"></a>rdb的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>与AOF方式相比，通过RDB文件恢复数据比较快</li><li>RDB文件非常紧凑，适用于数据备份</li><li>通过RDB进行数据备份，由于使用子进程生成，所以对Redis服务器性能影响较小<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的发布订阅模式</title>
      <link href="/2024/06/13/2024-06-2024-06-13-redis-de-fa-bu-ding-yue-mo-shi/"/>
      <url>/2024/06/13/2024-06-2024-06-13-redis-de-fa-bu-ding-yue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的发布订阅模式"><a href="#Redis的发布订阅模式" class="headerlink" title="Redis的发布订阅模式"></a>Redis的发布订阅模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是一款基于内存的非关系型数据库，提供了多种数据结构存储数据，存取数据的速度还很快，除了这些优点，它还提供了其他特色功能，比如：管道、发布订阅模式。</p><p>本文主要描述发布订阅模式的使用。</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>发布订阅是一种消息通信模式。</p><p><strong>发布者发送消息到频道（channel），订阅者接受频道的消息</strong></p><p><strong>其中发送者和订阅者都是客户端，频道维护在服务端</strong></p><p>Redis提供订阅频道、模式两种方式，模式可以理解为匹配正则的频道（比如 act.create匹配act.*模式）</p><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><ul><li><code>subscribe channel ...</code> 订阅一个或多个频道</li><li><code>unsubscribe channel ...</code> 退订一个或多个频道</li><li><code>psubscribe pattern ...</code> 订阅一个或多个符合模式的频道</li><li><code>publish channel message</code>  将消息发送到指定频道</li><li><code>pubsub subcommand argument...</code> 查看订阅与发布系统状态</li><li><code>punsubscribe pattern...</code> 退订所有给定模式的频道</li><li>以下是使用示例<pre class=" language-redis"><code class="language-redis">#testchannel为频道 hello!caicai为消息#客户端A发送消息 返回0 表示0个客户端接收 此时还没订阅频道   127.0.0.1:6379> publish testchannel hello!caicai(integer) 0​#客户端B订阅testchannel频道127.0.0.1:6379> subscribe testchannelReading messages... (press Ctrl-C to quit)1) "subscribe"2) "testchannel"3) (integer) 1​#客户端A发送消息 返回1 说明1个客户端接收到 127.0.0.1:6379> publish testchannel hello!caicai(integer) 1​#客户端B收到消息1) "message"2) "testchannel"3) "hello!caicai"​#客户端C使用模式进行订阅 订阅符合test*模式的频道(*为通配) testchannel符合test*127.0.0.1:6379> psubscribe test*Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "test*"3) (integer) 1​#客户端A发送消息 返回2 说明2个客户端接收到 127.0.0.1:6379> publish testchannel hello!caicai2(integer) 2​#客户端B显示1) "message"2) "testchannel"3) "hello!caicai2"​#客户端C显示1) "pmessage"2) "test*"3) "testchannel"4) "hello!caicai2"</code></pre></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>subscribe channel</code> 订阅频道维护字典，Key为频道，Value为链表，节点为订阅频道的客户端。客户端多月或退订频道则是在字典中添加/删除。</p><p><code>psubscribe pattern</code> 订阅模式维护链表，节点为模式名与客户端。客户端订阅或退订模式则是在链表上遍历添加/删除。</p><p><code>publish</code> 发送消息时，先找到字典中的Key频道遍历链表发送消息，再去模式中的链表上遍历是否与节点上的模式名匹配，匹配啧发送消息给对应客户端。</p><p>通过发布订阅模型能够实现订阅、通知系统，哨兵模式中也使用发布订阅模式，哨兵订阅主节点，主节点收到某个哨兵命令后发送返回信息，各个哨兵收到消息后能够感知其他哨兵的存在。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的三种集群方式及原理</title>
      <link href="/2024/06/11/2024-06-2024-06-11-redis-de-san-chong-ji-qun-fang-shi-ji-yuan-li/"/>
      <url>/2024/06/11/2024-06-2024-06-11-redis-de-san-chong-ji-qun-fang-shi-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的三种集群方式及原理"><a href="#Redis的三种集群方式及原理" class="headerlink" title="Redis的三种集群方式及原理"></a>Redis的三种集群方式及原理</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>从服务器连接主服务器，发送SYNC命令</li><li>主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件，并使用缓冲区记录此后执行的所有写命令</li><li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令</li><li>从服务器完成对快照的载入，开始接受命令请求，并执行来自主服务器缓冲区的写命令（<strong>从服务器初始化完成</strong>）</li><li>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（<strong>从服务器初始化完成后的操作</strong>）<br>初始化完成之后，主从服务器之间会保持缓冲区写命令的同步</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离</li><li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务必须由Master来完成</li><li>Slave同样可以接受其他Slaves的连接和同步请求，这样可以有效的分载Master的同步压力</li><li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端可以提交查询或修改请求</li><li>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，则返回同步前的数据</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分的读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后会引入数据不一致的问题，降低了系统的可用性</li><li>Redis较难支持在线扩容，在集群容量达到上限时，在线扩容会变得复杂</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。为此Redis2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p><p>哨兵的作用就是监控Redis系统的运行状况。它的功能有以下两个：</p><ol><li>监控主服务器和从服务器是否正常运行</li><li>主服务器出现故障时自动将从服务器转换为主服务器</li></ol><p><img src="/img/example-20201228183842332.png" alt="哨兵原理"></p><h3 id="哨兵的工作方式"><a href="#哨兵的工作方式" class="headerlink" title="哨兵的工作方式"></a>哨兵的工作方式</h3><ol><li>每个哨兵进程以每秒一次的频率向整个集群的Master、Slave以及其他哨兵进程发送一个Ping命令</li><li>如果一个示例距离最后一次有效回复Ping命令的时间超过 <code>down-after-milliseconds</code> 设置的值，则这个实例会被哨兵进程标记为主观下线（SDOWN）</li><li>如果一个Master被标记为主观下线（SDOWN），则正在监视这个Master的所有哨兵进程都要以每秒一次的频率确认Master进入了主观下线状态（SDOWN）</li><li>当有足够数量的哨兵进程(大于配置文件指定的值)在指定时间范围内确认Master进入了主观下线状态，则Master会被标记为客观下线（ODOWN）</li><li>在一般情况下，每个哨兵进程会以每10秒一次的频率向集群中的所有Master、Slave发送INFO命令</li><li>当Master被哨兵进程标记为客观下线时，哨兵进程向下线的Master的所有Slave发送Info命令的频率会从10s一次改为1s一次</li><li>若没有足够数量的哨兵进程同意Master下线，Master的客观下线状态就会被移除。若Master重新向哨兵进程发送Ping命令返回有效回复，Master的主观下线状态就会被移除</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都有</li><li>主从可以自动切换，系统更健壮，可用性更高<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h2 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis-Cluster集群"></a>Redis-Cluster集群</h2><p>Redis的哨兵模式基本已经可以实现高可用，读写分离。但是在这种模式下每台服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了Cluster模式，实现了redis的分布式存储，也就是说在每台redis节点上存储不同的内容</p><p>Redis-Cluster采用无中心结构，它的特点如下:</p><ul><li>所有的redis节点彼此互联（ping-pong机制），内部使用二进制协议优化传输速度和带宽</li><li>节点的fail是通过集群中超过半数的节点检测失效时才会生效</li><li>客户端与redis节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个节点即可</li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的取值范围是0-16383。还有一个就是Cluster，可以理解为是一个集群管理插件。当我们存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对16383求余数，这样每个key都会对应一个编号在0-16383之间的哈希值，通过这个值找到对应插槽的节点，然后直接自动跳转到这个对应的节点上进行存取操作。<strong>一致性哈希算法解决分布式热点问题</strong></p><p>为了保证高可用，Redis-Cluster集群引入了主从模式，一个主节点对应一个或多个从节点，当主节点宕机的时候，就会启用从节点。当其他主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么主节点A宕机。如果主节点A和他的从节点A1都宕机，那么该集群无法再提供服务。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群搭建</title>
      <link href="/2024/06/10/2024-06-2024-06-10-redis-ji-qun-da-jian/"/>
      <url>/2024/06/10/2024-06-2024-06-10-redis-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上一篇博客介绍了主从复制的配置，接下来介绍如何使用 <code>redis-trib.rb</code> 搭建一个 <code>Redis</code>集群。</p><p><code>redis-trib.rb</code>是一款由 <code>Redis</code> 官方提供的集群管理工具，能够大量减少集群搭建的时间。除此之外，还能够简化集群的检查、槽迁徙、负载均衡等常见的运维操作。</p><p>在新版Redis中，redis-trib.rb工具的功能都被集成在了redis-cli里。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们使用 <code>redis-trib.rb</code> 前需要安装ruby环境</p><ol><li><p>使用yum安装ruby</p><pre class=" language-shell"><code class="language-shell">yum install -y rubygems</code></pre></li><li><p>默认的ruby包管理工具镜像源在国外，将国外源删除添加国内源</p><pre class=" language-shell"><code class="language-shell">gem sources --remove https://rubygems.org/gem sources -a http://mirrors.aliyun.com/rubygems/gem update --system</code></pre></li><li><p>使用ruby的包管理工具下载依赖包</p><pre class=" language-shell"><code class="language-shell">gem install redis</code></pre></li></ol><h2 id="集群准备"><a href="#集群准备" class="headerlink" title="集群准备"></a>集群准备</h2><p>因为集群最少需要6个节点，所以我们准备配置6份不同配置文件和工作目录的redis</p><pre class=" language-shell"><code class="language-shell">mkdir 7001 7002 7003 7004 7005 7006</code></pre><p>准备集群配置文件</p><pre class=" language-shell"><code class="language-shell">$ vim /home/test/redis-cluster/7001/redis.cnf# 守护进行模式启动daemonize yes# 设置数据库数量，默认数据库为0databases 16# 绑定地址，需要修改bind 192.168.0.120# 绑定端口，需要修改port 6379# pid文件存储位置，文件名需要修改pidfile /home/test/redis-cluster/7001/pid/redis_6379.pid# log文件存储位置，文件名需要修改logfile /home/test/redis-cluster/7001/logs/redis_6379.log# RDB快照备份文件名，文件名需要修改dbfilename redis_6379.rdb# 本地数据库存储目录，需要修改dir /home/test/redis-cluster/7001/# 集群相关配置# 是否以集群模式启动cluster-enabled yes# 集群节点回应最长时间，超过该时间被认为下线cluster-node-timeout 15000# 生成的集群节点配置文件名，文件名需要修改cluster-config-file nodes_6379.conf</code></pre><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><p>后台启动所有的redis服务</p><pre class=" language-shell"><code class="language-shell">$ nohup redis-server /home/test/redis-cluster/7001/redis.conf &$ nohup redis-server /home/test/redis-cluster/7002/redis.conf &$ nohup redis-server /home/test/redis-cluster/7003/redis.conf &$ nohup redis-server /home/test/redis-cluster/7004/redis.conf &$ nohup redis-server /home/test/redis-cluster/7005/redis.conf &$ nohup redis-server /home/test/redis-cluster/7006/redis.conf &</code></pre><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>现在我们还有两个步骤没有做</p><ol><li>对集群进行分槽工作</li><li>构建主从关系</li></ol><p>通过 <code>redis-trib.rb</code> 工具，这个步骤将会变得异常简单，只需要执行下面命令</p><pre class=" language-shell"><code class="language-shell"># 旧版Redis这里以脚本名开头 redis-trib.rb 跟上后面参数即可$ redis-cli --cluster create 192.168.0.120:6379 192.168.0.140:6380 192.168.0.130:6379 192.168.0.120:6380 192.168.0.140:6379 192.168.0.130:6380 --cluster-replicas 1</code></pre><blockquote><p>–cluster-replicas：指定的副本数，其实这一条命令的语法规则是如果副本数为1，第一个ip:port与它后面的1个ip:port建立1主1从关系，如果副本数是2，第一个ip:port与它后面的2个ip:port建立1主2从关系，以此类推。</p></blockquote><p>执行完这条命令后，输入yes，会看到以下信息：</p><pre class=" language-shell"><code class="language-shell"># 主从相关>>> Performing hash slots allocation on 6 nodes...Master[0] -> Slots 0 - 5460Master[1] -> Slots 5461 - 10922Master[2] -> Slots 10923 - 16383Adding replica 192.168.0.140:6379 to 192.168.0.120:6379Adding replica 192.168.0.130:6380 to 192.168.0.140:6380Adding replica 192.168.0.120:6380 to 192.168.0.130:6379M: c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379   slots:[0-5460] (5461 slots) masterM: 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380   slots:[5461-10922] (5462 slots) masterM: 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379   slots:[10923-16383] (5461 slots) masterS: d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380   replicates 282358c2fb0c7c16ec60f2c4043b52a0eb91e19fS: 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379   replicates c71b52f728ab58fedb6e05a525ce00b453fd2f6bS: ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380   replicates 6a627cedaa4576b1580806ae0094be59c32fa391# 询问是否保存配置？输入yesCan I set the above configuration? (type 'yes' to accept): yes>>> Nodes configuration updated>>> Assign a different config epoch to each node>>> Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.# 分槽相关，全部自动进行，无需手动操作>>> Performing Cluster Check (using node 192.168.0.120:6379)M: c71b52f728ab58fedb6e05a525ce00b453fd2f6b 192.168.0.120:6379   slots:[0-5460] (5461 slots) master   1 additional replica(s)M: 282358c2fb0c7c16ec60f2c4043b52a0eb91e19f 192.168.0.130:6379   slots:[10923-16383] (5461 slots) master   1 additional replica(s)M: 6a627cedaa4576b1580806ae0094be59c32fa391 192.168.0.140:6380   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: d645d06708e1eddb126a6c3c4e38810c188d0906 192.168.0.120:6380   slots: (0 slots) slave   replicates 282358c2fb0c7c16ec60f2c4043b52a0eb91e19fS: 7a7392cb66bea30da401d2cb9768a42bbdefc5db 192.168.0.140:6379   slots: (0 slots) slave   replicates c71b52f728ab58fedb6e05a525ce00b453fd2f6bS: ff53e43f9404981a51d4e744de38004a5c22b090 192.168.0.130:6380   slots: (0 slots) slave   replicates 6a627cedaa4576b1580806ae0094be59c32fa391[OK] All nodes agree about slots configuration.>>> Check for open slots...>>> Check slots coverage...[OK] All 16384 slots covered.</code></pre><p><a href="https://www.cnblogs.com/Yunya-Cnblogs/p/14611220.html" target="_blank" rel="noopener">Redis 超详细自动管理Cluster集群工具上手 redis-trib.rb</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制配置</title>
      <link href="/2024/06/10/2024-06-2024-06-10-redis-zhu-cong-fu-zhi-pei-zhi/"/>
      <url>/2024/06/10/2024-06-2024-06-10-redis-zhu-cong-fu-zhi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制配置"><a href="#Redis主从复制配置" class="headerlink" title="Redis主从复制配置"></a>Redis主从复制配置</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们的应用出现高流量高并发的情况下，通常会使用缓存来提高系统的吞吐量，如果当流量超过了缓存的性能瓶颈后，我们需要对缓存进行水平扩容来提高他的并发能力，那么这就需要搭建Redis主从集群，实现读写分离。</p><p>使用Redis主从集群后，就能提供系统的高可用性。</p><p>接下来介绍下主从复制的使用。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>要在同一个虚拟机里准备3个 <code>Redis</code> 实例，必须准备3份不同的配置文件和工作目录。</p><p><img src="/img/example-9740ef249e564093a5e84da42adf3b3a.png" alt="主从集群原理图"></p><p>现在我们来搭建一个三节点的集群，包括一个主节点(master)和两个从节点(slave)。</p><p>我在一个<code>Ubuntu</code>虚拟机里开启3个redis实例，模拟主从集群，信息如下:</p><ul><li>主节点 端口是<code>7001</code></li><li>从节点 端口是<code>7002</code>,<code>7003</code></li></ul><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><h4 id="安装-redis-server"><a href="#安装-redis-server" class="headerlink" title="安装 redis-server"></a>安装 <code>redis-server</code></h4><pre class=" language-shell"><code class="language-shell">sudo apt-get update  sudo apt-get install redis-server</code></pre><h4 id="修改主库配置文件"><a href="#修改主库配置文件" class="headerlink" title="修改主库配置文件"></a>修改主库配置文件</h4><pre class=" language-ini"><code class="language-ini">vim /etc/redis/7001/redis.conf# bind 127.0.0.1 ::1   注释掉这个外链地址 允许外部连接</code></pre><h4 id="复制并修改从库配置文件"><a href="#复制并修改从库配置文件" class="headerlink" title="复制并修改从库配置文件"></a>复制并修改从库配置文件</h4><pre class=" language-ini"><code class="language-ini">vim /etc/redis/7002/redis.confvim /etc/redis/7003/redis.conf# slaveof 主库ip 主库端口号  把这行注释打开并填上主库的ip和端口号</code></pre><h4 id="重启并验证"><a href="#重启并验证" class="headerlink" title="重启并验证"></a>重启并验证</h4><p>配置完3个节点的配置文件后，重启redis，然后使用<code>redis-cli</code>连接主库，输入命令<code>info replication</code></p><p><img src="/img/example-5fb92ee6fdfc4f52aef2a2f727ceaf90.png" alt="命令"></p><p>命令打印出的从节点数量为2，即主从复制配置成功。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-FPM调优</title>
      <link href="/2024/06/04/2024-06-2024-06-04-php-fpm-diao-you/"/>
      <url>/2024/06/04/2024-06-2024-06-04-php-fpm-diao-you/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-FPM调优"><a href="#PHP-FPM调优" class="headerlink" title="PHP-FPM调优"></a>PHP-FPM调优</h1><h3 id="PHP的几种运行方式"><a href="#PHP的几种运行方式" class="headerlink" title="PHP的几种运行方式"></a>PHP的几种运行方式</h3><p><code>PHP</code> 本身是一个php代码的脚本执行程序，他有以下几种运行方式：</p><ul><li>模块加载运行方式（<code>Apache</code>）</li><li>CGI运行方式 (<code>Apache</code>)</li><li>FastCGI运行方式 （几乎通用）</li><li>ISAPI运行方式（Window下Apache）</li><li>CLI运行方式（命令行）</li></ul><p>前四种是提供给web服务器来处理php代码文件，其中模块加载的方式其实是最快的，但 <code>FastCGI</code> 配合 <code>NGINX</code>的web服务是目前的主流。</p><h3 id="从CGI到PHP-FPM"><a href="#从CGI到PHP-FPM" class="headerlink" title="从CGI到PHP-FPM"></a>从CGI到PHP-FPM</h3><ul><li><strong>CGI</strong></li></ul><p><code>Common Gateway Interface(公共网关接口)</code>简称 <code>CGI</code>，每当客户请求 <code>CGI</code> 的时候，<code>WEB</code> 服务器就请求操作系统生成一个新的<code>CGI</code>解释器进程,<code>CGI</code>的一个进程则处理完一个请求后退出，下一个请求来时再创建新进程。这样在访问量少的情况也还能使用，可是当访问量增加，产生并发的情况下，这种方式就不适合了，于是就有了 <code>FastCGI</code></p><ul><li><strong>FastCGI</strong></li></ul><p><code>FastCGI</code>像是一个常驻型的<code>CGI</code>，它可以一直执行着，只要激活后，不会每次都话费时间去<code>fork</code>一次。</p><p>在启动<code>FastCGI</code>的时候它就启动了多个<code>CGI</code>解释器进程并等待 <code>Web Server</code>的请求，结束完就又重新等待请求。</p><ul><li><strong>PHP-FPM</strong><br><code>PHP-FPM</code>就是<code>FastCGI</code>的实现，并提供了进程管理的功能，进程包含<code>master</code>进程和<code>worker</code>进程两种，<code>master</code>进程只有一个，负责监听端口，接收请求，而<code>worker</code>进程则一般有多个(具体数量根据实际需要配置)。</li></ul><p>每个进程内部都嵌入了一个<code>PHP</code>解释器，是<code>PHP</code>代码真正执行的地方。</p><h3 id="多方面调优"><a href="#多方面调优" class="headerlink" title="多方面调优"></a>多方面调优</h3><h4 id="php-ini配置"><a href="#php-ini配置" class="headerlink" title="php.ini配置"></a><strong>php.ini配置</strong></h4><pre class=" language-ini"><code class="language-ini"><span class="token comment" spellcheck="true">;这个是配置禁用危险函数</span><span class="token constant">disable_functions</span><span class="token attr-value"><span class="token punctuation">=</span>eval... </span><span class="token comment" spellcheck="true">;上传文件大小限制</span><span class="token constant">post_max_size</span> <span class="token attr-value"><span class="token punctuation">=</span>16M</span><span class="token constant">upload_max_filesize</span><span class="token attr-value"><span class="token punctuation">=</span> 16M</span><span class="token comment" spellcheck="true">;脚本执行时间限制</span><span class="token constant">max_execution_time</span><span class="token attr-value"><span class="token punctuation">=</span> 60</span><span class="token constant">max_input_time</span> <span class="token attr-value"><span class="token punctuation">=</span>60</span><span class="token comment" spellcheck="true">;脚本内存限制，一般设为128M，如非必要（无可避免的上传大文件/处理大数组）不增加</span><span class="token constant">memory_limit</span> <span class="token attr-value"><span class="token punctuation">=</span>128M</span></code></pre><h4 id="php-fpm配置"><a href="#php-fpm配置" class="headerlink" title="php-fpm配置"></a><strong>php-fpm配置</strong></h4><pre class=" language-ini"><code class="language-ini"><span class="token comment" spellcheck="true">;错误日志处理</span><span class="token constant">error_log</span> <span class="token attr-value"><span class="token punctuation">=</span>/var/log/php-fpm/error.log</span><span class="token constant">log_level</span> <span class="token attr-value"><span class="token punctuation">=</span> notice</span><span class="token comment" spellcheck="true">;异常自启（表示60s内出现 60次 SIGSEGV orSIGBUS 异常时候，自动重启）</span><span class="token constant">emergency_restart_threshold</span><span class="token attr-value"><span class="token punctuation">=</span> 60</span><span class="token constant">emergency_restart_interval</span><span class="token attr-value"><span class="token punctuation">=</span> 60s</span><span class="token comment" spellcheck="true">;设置子进程接受主进程复用信号的超时时间</span><span class="token constant">process_control_timeout</span><span class="token attr-value"><span class="token punctuation">=</span> 0</span><span class="token comment" spellcheck="true">;后台执行php-fpm</span><span class="token constant">daemonize</span> <span class="token attr-value"><span class="token punctuation">=</span> yes</span></code></pre><h4 id="pool资源池配置"><a href="#pool资源池配置" class="headerlink" title="pool资源池配置"></a><strong>pool资源池配置</strong></h4><p>每个文件代表一个资源池,机器性能足够时，可以区分多个资源池，隔绝不同的php应用,默认是<code>www.conf</code></p><pre class=" language-ini"><code class="language-ini"><span class="token comment" spellcheck="true">;监听方式，用tcp方式较稳定</span><span class="token constant">listen</span> <span class="token attr-value"><span class="token punctuation">=</span> 127.0.0.1:9000</span><span class="token comment" spellcheck="true">;backlog，排队长度设置</span><span class="token constant">listen.backlog</span> <span class="token attr-value"><span class="token punctuation">=</span> 4096</span><span class="token comment" spellcheck="true">;慢处理日志，表示超过45秒则记录为慢处理</span><span class="token constant">request_slowlog_timeout</span> <span class="token attr-value"><span class="token punctuation">=</span> 45s</span><span class="token constant">slowlog</span> <span class="token attr-value"><span class="token punctuation">=</span> /var/log/php-fpm/www-slow.log</span></code></pre><h3 id="具体设置问题"><a href="#具体设置问题" class="headerlink" title="具体设置问题"></a>具体设置问题</h3><ul><li><strong>pm</strong></li></ul><p><code>pm</code>默认是<code>dynamic</code>动态的，但是一般我们的生产环境都是设置静态<code>static</code></p><ul><li><strong>pm.max_children</strong></li></ul><p>最大子进程数量，越多越好，但是受限机器性能，因此需要根据机器来配置，一般每个<code>php-cgi</code>耗费的内存为<code>20M~40M</code>，如果最大数量设置为100，那么总共需要的内存就在<code>2000M~4000M</code>，如果这个值设置的比较小，那么等待的请求时间会出现502超时，所以需要根据服务器运行的程序大小，计算出剩余内存，再计算子进程数。</p><ul><li><strong>pm.max_requests</strong></li></ul><p>为了避免内存泄露，<code>PHP-FPM</code>有这么一个机制，当一个<code>php-cgi</code>进程处理的请求数达到这个配置后，则会重启该进程，所以在高并发的情况下，经常导致502错误，解决方法就是把这个值设置大一点，减少进程重启次数，一般设置1024</p><ul><li><strong>pm.min_spare_servers</strong></li></ul><p>保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程，一般可以设置为10</p><ul><li><strong>pm.max_spare_servers</strong></li></ul><p>保证空闲进程数最大值，如果空闲进程大于此值，则进行清理，一般可以设置为30</p><ul><li><strong>request_terminate_timeout</strong></li></ul><p>单个请求的超时终止时间，超时后会终止进程,<code>nginx</code>发现信号中断，就会给客户端返回502</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从PHPUnit开始编写单元测试</title>
      <link href="/2024/06/03/2024-06-2024-06-03-cong-phpunit-kai-shi-bian-xie-dan-yuan-ce-shi/"/>
      <url>/2024/06/03/2024-06-2024-06-03-cong-phpunit-kai-shi-bian-xie-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="从PHPUnit开始编写单元测试"><a href="#从PHPUnit开始编写单元测试" class="headerlink" title="从PHPUnit开始编写单元测试"></a>从PHPUnit开始编写单元测试</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中为什么要做测试呢？</p><p>即时是很小规模的项目开发也需要数小时的辛苦编程。在开发过程中，应用代码中或多或少都会存在一些大大小小的问题，开发者往往会尝试在开发过程中解决这些问题，以便顺利上线。</p><p>但问题是在未经完整测试的情况下，没有一种方式可以确保最终上线代码没有任何问题，此外也没有办法确保修复老问题的代码不会引起新问题。</p><p>为了解决上述问题，我们才需要在开发过程中引入测试流程，并将其作为日常开发流程中不可或缺的一部分，从而确保代码质量。</p><p>在现代软件开发流程中，测试驱动开发、持续交付、持续集成这些概念都将测试作为开发流程的一部分，要求我们在软件开发的一开始，就要设计好相关的测试方法，从而让代码更加易于扩展、迭代和维护。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>常见的测试主要包括单元测试和功能测试</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是一种通过编写测试代码来确认函数、类和方法是否以我们预期的方式来工作，单元测试会贯穿整个项目的开发周期。通过检查各个函数和方法的输入输出，就可以保证代码内部的逻辑已经正确执行。</p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>功能测试是通过使用工具来生成自动化的测试用例，然后再真实的系统上运行，而不是单元测试中简单的验证单个模块的正确性。这些工具会使用有代表性的真实数据来模拟真实用户的行为从而验证系统的正确性。</p><h3 id="PHPUnit简介和安装配置"><a href="#PHPUnit简介和安装配置" class="headerlink" title="PHPUnit简介和安装配置"></a>PHPUnit简介和安装配置</h3><p>在 <code>PHP</code> 中，最著名的单元测试框架就是 <code>PHPUnit</code> 了，下面将以 <code>PHPUnit</code> 为例，介绍如何在项目中进行单元测试</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>如果在 <code>Laravel</code> 项目中，<code>PHPUnit</code>已经默认集成了，如果是在其他项目中使用，可以通过composer进行安装</p><pre class=" language-shell"><code class="language-shell">composer require --dev phpunit/phpunit ^7</code></pre><blockquote><p>由于不会在线上环境进行测试，所以使用 <code>--dev</code> 表示仅在本地安装</p></blockquote><h3 id="编写一个测试用例"><a href="#编写一个测试用例" class="headerlink" title="编写一个测试用例"></a>编写一个测试用例</h3><h4 id="单元测试的基本约定"><a href="#单元测试的基本约定" class="headerlink" title="单元测试的基本约定"></a>单元测试的基本约定</h4><ul><li><strong>测试文件名需要以 <code>Test</code> 作为后缀，比如要测试 <code>Activity.php</code> 文件，则对应的测试文件名为 <code>ActivityTest.php</code>。</strong></li><li><strong>测试方法名需要以 <code>test</code> 作为前缀，比如需要测试的方法为 <code>getInfo</code> ，则对应的测试方法名为 <code>testGetInfo</code>,此外可以通过 <code>@test</code>注解来声明一个测试方法。</strong></li><li><strong>所有测试方法必须是 <code>public</code>。</strong></li><li><strong>所有的测试类都继承自 <code>PHPUnit\Framework\TestCase</code>。</strong></li></ul><h4 id="编写简单测试用例"><a href="#编写简单测试用例" class="headerlink" title="编写简单测试用例"></a>编写简单测试用例</h4><p>首先，来创建一个简单的测试用例，将其命名为 <code>ActivityTest.php</code>，这仅仅是为了写测试用例而写，不是对任何业务代码做测试。</p><p><img src="/img/example-1717915092162.jpg" alt="简单测试用例"></p><p>然后我们就可以运行 <code>vendor/bin/phpunit</code> 命令来对刚刚的代码进行测试</p><p><img src="/img/example-1717915374428.jpg" alt="测试命令"></p><p>通过编排文件 <code>phpunit.xml</code>, <code>PHPUnit</code> 会去 <code>tests/Unit</code>目录中查找测试用例进行测试，测试通过则显示绿色的高亮文本，测试不通过则显示红色的警告文本。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> PHPUnit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-备忘录模式</title>
      <link href="/2024/05/25/2024-05-2024-05-25-23-chong-she-ji-mo-shi-bei-wang-lu-mo-shi/"/>
      <url>/2024/05/25/2024-05-2024-05-25-23-chong-she-ji-mo-shi-bei-wang-lu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-备忘录模式"><a href="#23种设计模式-备忘录模式" class="headerlink" title="23种设计模式-备忘录模式"></a>23种设计模式-备忘录模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>又称快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>备忘录模式有以下角色：</p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合了单一职责原则。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>资源消耗大，如果要保存内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-访问者模式</title>
      <link href="/2024/05/24/2024-05-2024-05-24-23-chong-she-ji-mo-shi-fang-wen-zhe-mo-shi/"/>
      <url>/2024/05/24/2024-05-2024-05-24-23-chong-she-ji-mo-shi-fang-wen-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-访问者模式"><a href="#23种设计模式-访问者模式" class="headerlink" title="23种设计模式-访问者模式"></a>23种设计模式-访问者模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>访问者模式有以下角色：</p><ul><li>抽象访问者（Visitor）角色：定义了对每一个元素访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数一样，从这点不难看出，访问者模式要求元素类的个数不能改变。</li><li>具体访问者角色：给出对每一个元素类访问时所产生的具体行为。</li><li>抽象元素（Element）角色：定义了一个接受访问者的方法，其意义是指，每一个元素都要可以被访问者访问。</li><li>具体元素角色：提供接收访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>对象结构（Object Structure）角色：定义所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素，并且可以迭代这些元素，供访问者访问。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>扩展性好，在不修改对象结构的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好，通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</li><li>分离无关行为，通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对象结构变化很困难，在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则。</li><li>违反了依赖倒置原则，访问者模式依赖了具体类，而不是接口或者抽象类。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-迭代器模式</title>
      <link href="/2024/05/23/2024-05-2024-05-23-23-chong-she-ji-mo-shi-die-dai-qi-mo-shi/"/>
      <url>/2024/05/23/2024-05-2024-05-23-23-chong-she-ji-mo-shi-die-dai-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-迭代器模式"><a href="#23种设计模式-迭代器模式" class="headerlink" title="23种设计模式-迭代器模式"></a>23种设计模式-迭代器模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>迭代器模式包含以下角色：</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li><li>具体聚合角色：实现抽象聚合类，返回一个具体迭代器的实力。</li><li>抽象迭代器（Iterator）角色：定义访问和便利聚合元素的接口，通常包含hasNext()、next() 等方法。</li><li>具体迭代器角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-中介者模式</title>
      <link href="/2024/05/22/2024-05-2024-05-22-23-chong-she-ji-mo-shi-zhong-jie-zhe-mo-shi/"/>
      <url>/2024/05/22/2024-05-2024-05-22-23-chong-she-ji-mo-shi-zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-中介者模式"><a href="#23种设计模式-中介者模式" class="headerlink" title="23种设计模式-中介者模式"></a>23种设计模式-中介者模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>中介者模式包含以下角色：</p><ul><li>抽象中介者（Mediator）角色：他是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-观察者模式</title>
      <link href="/2024/05/22/2024-05-2024-05-22-23-chong-she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
      <url>/2024/05/22/2024-05-2024-05-22-23-chong-she-ji-mo-shi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-观察者模式"><a href="#23种设计模式-观察者模式" class="headerlink" title="23种设计模式-观察者模式"></a>23种设计模式-观察者模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>观察者模式又被称为 <code>发布-订阅</code>(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>观察者模式有以下角色：</p><ul><li>抽象主题（Subject）：抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>具体主题（Concrete Subject）：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>抽象观察者（Observer）：是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>具体观察者（Concrete Observer）：实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 抽象观察者 */</span><span class="token keyword">interface</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象主题 */</span><span class="token keyword">interface</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer <span class="token variable">$observer</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer <span class="token variable">$observer</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Event</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$observers</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer <span class="token variable">$observer</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">observers</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$observer</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer <span class="token variable">$observer</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">observers</span> <span class="token keyword">as</span> <span class="token variable">$k</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$v</span> <span class="token operator">===</span> <span class="token variable">$observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">observers</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">observers</span> <span class="token keyword">as</span> <span class="token variable">$observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$observer</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体观察者 */</span><span class="token keyword">class</span> <span class="token class-name">Listener</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'监听事件了'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体主题 */</span><span class="token keyword">class</span> <span class="token class-name">Job</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$subject</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$subject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addObserver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$subject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息，实现了广播机制</li></ul></li><li>缺点<ul><li>如果观察者非常多的话，那么所有观察者收到被观察者发送的通知会耗时长</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖另一个方面时。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-状态模式</title>
      <link href="/2024/05/21/2024-05-2024-05-21-23-chong-she-ji-mo-shi-zhuang-tai-mo-shi/"/>
      <url>/2024/05/21/2024-05-2024-05-21-23-chong-she-ji-mo-shi-zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-状态模式"><a href="#23种设计模式-状态模式" class="headerlink" title="23种设计模式-状态模式"></a>23种设计模式-状态模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对有状态的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>状态模式包含以下角色：</p><ul><li>环境（Context）角色：也称上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态角色：实现抽象状态对应的行为。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li></ul></li><li>缺点<ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构的代码混乱。</li><li>状态模式对开闭原则的支持并不太好。</li></ul></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改编它的行为时，就可以考虑使用状态模式。<br>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-责任链模式</title>
      <link href="/2024/05/20/2024-05-2024-05-20-23-chong-she-ji-mo-shi-ze-ren-lian-mo-shi/"/>
      <url>/2024/05/20/2024-05-2024-05-20-23-chong-she-ji-mo-shi-ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-责任链模式"><a href="#23种设计模式-责任链模式" class="headerlink" title="23种设计模式-责任链模式"></a>23种设计模式-责任链模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有的请求的处理者通过前一对象记住其下一个对象的引用而连成一条链。当有请求发生时，可将请求沿着这条链传递，直到有对象处理它位置。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>责任链模式包含以下角色：</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低了对象之间的耦合度</li><li>增强了系统的可扩展性</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态增加或删除责任。</li><li>责任链简化了对象之间的连接。一个对象只需保持一个指向其后继者的引用，不需要保持其他处理者的引用，这避免了ifelse地狱。</li><li>责任分担。每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链的错误设置而导致系统出错。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-命令模式</title>
      <link href="/2024/05/20/2024-05-2024-05-20-23-chong-she-ji-mo-shi-ming-ling-mo-shi/"/>
      <url>/2024/05/20/2024-05-2024-05-20-23-chong-she-ji-mo-shi-ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-命令模式"><a href="#23种设计模式-命令模式" class="headerlink" title="23种设计模式-命令模式"></a>23种设计模式-命令模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>命令模式包含以下角色：</p><ul><li>抽象命令类（Command）角色：定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete Command）角色：具体的命令，实现命令接口。通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>调用者/请求者（Invoker）角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多命令对象。这个是客户端真正出发命令并要求命令执行相应操作的地方。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>使用命令模式可能会导致某些系统又过多的具体命令类。</li><li>系统结构更加复杂。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销和恢复操作。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-策略模式</title>
      <link href="/2024/05/17/2024-05-2024-05-17-23-chong-she-ji-mo-shi-ce-lue-mo-shi/"/>
      <url>/2024/05/17/2024-05-2024-05-17-23-chong-she-ji-mo-shi-ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-策略模式"><a href="#23种设计模式-策略模式" class="headerlink" title="23种设计模式-策略模式"></a>23种设计模式-策略模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>策略模式主要角色如下：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现，此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 第三方支付服务接口 * 抽象策略类 */</span><span class="token keyword">interface</span> <span class="token class-name">Pay</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体策略类 */</span><span class="token keyword">class</span> <span class="token class-name">Join</span> <span class="token keyword">implements</span> <span class="token class-name">Pay</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'聚合支付订单参数'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'执行聚合支付回调'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体策略类 */</span><span class="token keyword">class</span> <span class="token class-name">Wechat</span> <span class="token keyword">implements</span> <span class="token class-name">Pay</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'微信支付订单参数'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'执行微信支付回调'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">PayContext</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> Pay <span class="token variable">$pay</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">pay</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">pay</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$joinPay</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayContext</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$joinPay</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getPayParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$joinPay</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>策略类之间可以自由切换</li><li>易于扩展，增加一个新的策略只需要添加一个具体的策略类即可</li><li>避免使用多重条件选择语句<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统需要动态的在几种算法中选择一种时，可将每个算法封装到具体的策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-模版方法模式</title>
      <link href="/2024/05/16/2024-05-2024-05-16-23-chong-she-ji-mo-shi-mo-ban-fang-fa-mo-shi/"/>
      <url>/2024/05/16/2024-05-2024-05-16-23-chong-she-ji-mo-shi-mo-ban-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-模版方法模式"><a href="#23种设计模式-模版方法模式" class="headerlink" title="23种设计模式-模版方法模式"></a>23种设计模式-模版方法模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下，重定义该算法的某些特定步骤。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>模版方法模式包含以下主要角色：</p><ul><li>抽象类：负责给出一个算法的轮廓和骨架，它由一个模版方法和若干个基本方法构成。<ul><li>模版方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是实现算法各个步骤的方法，是模版方法的组成部分。基本方法又可以分为三种：<ul><li>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。</li><li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li></ul></li></ul></li><li>具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-组合模式</title>
      <link href="/2024/05/16/2024-05-2024-05-16-23-chong-she-ji-mo-shi-zu-he-mo-shi/"/>
      <url>/2024/05/16/2024-05-2024-05-16-23-chong-she-ji-mo-shi-zu-he-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-组合模式"><a href="#23种设计模式-组合模式" class="headerlink" title="23种设计模式-组合模式"></a>23种设计模式-组合模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>组合模式又名部分整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>组合模式主要包含以下角色：</p><ul><li>抽象根节点：定义系统各层次对象的公有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 表单结构抽象类 * 抽象根节点 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">FormStructure</span><span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token variable">$indent</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 根节点 */</span><span class="token keyword">class</span> <span class="token class-name">Form</span> <span class="token keyword">extends</span> <span class="token class-name">FormStructure</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$elements</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token variable">$indent</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$formCode</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">elements</span> <span class="token keyword">as</span> <span class="token variable">$element</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$formCode</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token variable">$element</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">render</span><span class="token punctuation">(</span><span class="token variable">$indent</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$formCode</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>FormStructure <span class="token variable">$element</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">elements</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$element</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 叶子节点 */</span><span class="token keyword">class</span> <span class="token class-name">InputElement</span> <span class="token keyword">extends</span> <span class="token class-name">FormStructure</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token variable">$indent</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">str_repeat</span><span class="token punctuation">(</span><span class="token string">'  '</span><span class="token punctuation">,</span><span class="token variable">$indent</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token string">'&lt;input type="text" />'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$form</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$form</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$form</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$secondForm</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$secondForm</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$form</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$secondForm</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$form</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-外观模式</title>
      <link href="/2024/05/15/2024-05-2024-05-15-23-chong-she-ji-mo-shi-wai-guan-mo-shi/"/>
      <url>/2024/05/15/2024-05-2024-05-15-23-chong-she-ji-mo-shi-wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-外观模式"><a href="#23种设计模式-外观模式" class="headerlink" title="23种设计模式-外观模式"></a>23种设计模式-外观模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>外观模式又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口。外部程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>外观模式包含以下角色：</p><ul><li>外观角色：为多个子系统对外提供一个共同的接口</li><li>子系统角色：实现系统的部分功能，客户可以通过外观角色访问它</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/*** 比如有一个子系统，我需要导出数据去做年终总结，那我需要导出订单相关数据和用户相关数据 */</span><span class="token keyword">interface</span> <span class="token class-name">Export</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 用户数据导出类 */</span><span class="token keyword">class</span> <span class="token class-name">UserExport</span> <span class="token keyword">implements</span> <span class="token class-name">Export</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'导出用户数据'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 订单数据导出类 */</span><span class="token keyword">class</span> <span class="token class-name">OrderExport</span> <span class="token keyword">implements</span> <span class="token class-name">Export</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'导出订单数据'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 导出门面类 */</span><span class="token keyword">class</span> <span class="token class-name">ExportFacade</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> Export <span class="token variable">$userExport</span><span class="token punctuation">,</span> <span class="token keyword">public</span> Export <span class="token variable">$orderExport</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">userExport</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">orderExport</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$exportService</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExportFacade</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserExport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">OrderExport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$exportService</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">export</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-桥接模式</title>
      <link href="/2024/05/14/2024-05-2024-05-14-23-chong-she-ji-mo-shi-qiao-jie-mo-shi/"/>
      <url>/2024/05/14/2024-05-2024-05-14-23-chong-she-ji-mo-shi-qiao-jie-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-桥接模式"><a href="#23种设计模式-桥接模式" class="headerlink" title="23种设计模式-桥接模式"></a>23种设计模式-桥接模式</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>桥接模式是指<strong>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现。从而降低了抽象和实现这两个可变维度的耦合度</strong></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>桥接模式包含一下主要角色：</p><ul><li>抽象化角色：定义抽象类，并包含一个对实现化对象的引用</li><li>扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</li><li>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用</li><li>具体实现化角色：给出实现化角色接口的具体实现</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 软件接口 * 实现化角色 */</span><span class="token keyword">interface</span> <span class="token class-name">Software</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 谷歌浏览器 * 具体实现化角色 */</span><span class="token keyword">class</span> <span class="token class-name">Google</span> <span class="token keyword">implements</span> <span class="token class-name">Software</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'谷歌浏览器 '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 火狐浏览器 * 具体实现化角色 */</span><span class="token keyword">class</span> <span class="token class-name">Firefox</span> <span class="token keyword">implements</span> <span class="token class-name">Software</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'火狐浏览器'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象化角色 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">System</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> Software <span class="token variable">$software</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Mac系统 * 扩展抽象化角色 */</span><span class="token keyword">class</span> <span class="token class-name">Mac</span> <span class="token keyword">extends</span> <span class="token class-name">System</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"mac"</span><span class="token punctuation">.</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">software</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Window系统 * 扩展抽象化角色 */</span><span class="token keyword">class</span> <span class="token class-name">Windows</span> <span class="token keyword">extends</span> <span class="token class-name">System</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"windows"</span><span class="token punctuation">.</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">software</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$mac</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mac</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Google</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$mac</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mac 谷歌浏览器</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-装饰模式</title>
      <link href="/2024/05/13/2024-05-2024-05-13-23-chong-she-ji-mo-shi-zhuang-shi-mo-shi/"/>
      <url>/2024/05/13/2024-05-2024-05-13-23-chong-she-ji-mo-shi-zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-装饰模式"><a href="#23种设计模式-装饰模式" class="headerlink" title="23种设计模式-装饰模式"></a>23种设计模式-装饰模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>装饰模式是指<strong>在不改变现有对象结构的情况下，动态的给该对象增加一些职责（即增加其额外功能）的模式</strong></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>装饰模式分为以下角色：</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象</li><li>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责</li><li>抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类拓展具体构件的功能</li><li>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 比如说我现在要举行一个活动，这个活动可以有抽奖、拼团等功能 */</span><span class="token comment" spellcheck="true">/** * 抽象构件 */</span><span class="token keyword">interface</span> <span class="token class-name">ActivityInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体构件 */</span><span class="token keyword">class</span> <span class="token class-name">Activity</span> <span class="token keyword">implements</span> <span class="token class-name">ActivityInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'开始活动'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象装饰器 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ActivityDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">ActivityInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> ActivityInterface <span class="token variable">$activity</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体装饰器 */</span><span class="token keyword">class</span> <span class="token class-name">Group</span> <span class="token keyword">extends</span> <span class="token class-name">ActivityDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'设置拼团功能'</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">activity</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体装饰器 */</span><span class="token keyword">class</span> <span class="token class-name">Draw</span> <span class="token keyword">extends</span> <span class="token class-name">ActivityDecorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'设置抽奖功能'</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">activity</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$activity</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Activity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 增加拼团功能</span><span class="token variable">$groupActivity</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Group</span><span class="token punctuation">(</span><span class="token variable">$activity</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 增加抽象功能</span><span class="token variable">$drawGroupActivity</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Draw</span><span class="token punctuation">(</span><span class="token variable">$groupActivity</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开始活动</span><span class="token variable">$drawGroupActivity</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印结果：设置抽奖功能设置拼团功能开始活动</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-适配器模式</title>
      <link href="/2024/05/10/2024-05-2024-05-10-23-chong-she-ji-mo-shi-gua-pei-qi-mo-shi/"/>
      <url>/2024/05/10/2024-05-2024-05-10-23-chong-she-ji-mo-shi-gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-适配器模式"><a href="#23种设计模式-适配器模式" class="headerlink" title="23种设计模式-适配器模式"></a>23种设计模式-适配器模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>适配器（Adapter）模式包含下面角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口格式访问适配者</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 目标接口 */</span><span class="token keyword">interface</span> <span class="token class-name">SDCard</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">writeSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 适配者接口 */</span><span class="token keyword">interface</span> <span class="token class-name">TFCard</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">writeTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 适配者实现类 */</span><span class="token keyword">class</span> <span class="token class-name">TfCardImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TFCard</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'读tf'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">writeTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'写tf'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SDAdapterTF</span> <span class="token keyword">implements</span> <span class="token class-name">SDCard</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">protected</span> TFCard <span class="token variable">$tfCard</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">tfCard</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">writeSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">tfCard</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">writeTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">readCard</span><span class="token punctuation">(</span>SDCard <span class="token variable">$sdcard</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$sdcard</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试</span><span class="token variable">$computer</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Computer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$adapter</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SDAdapterTF</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TfCardImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$computer</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readCard</span><span class="token punctuation">(</span><span class="token variable">$adapter</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-代理模式</title>
      <link href="/2024/05/10/2024-05-2024-05-10-23-chong-she-ji-mo-shi-dai-li-mo-shi/"/>
      <url>/2024/05/10/2024-05-2024-05-10-23-chong-she-ji-mo-shi-dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-代理模式"><a href="#23种设计模式-代理模式" class="headerlink" title="23种设计模式-代理模式"></a>23种设计模式-代理模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>代理模式分为三种角色：</p><ul><li>抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 抽象主题 */</span><span class="token keyword">interface</span> <span class="token class-name">InternationalWeb</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 真实主题 */</span><span class="token keyword">class</span> <span class="token class-name">Facebook</span> <span class="token keyword">implements</span> <span class="token class-name">InternationalWeb</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'脸书页面'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 代理类 */</span><span class="token keyword">class</span> <span class="token class-name">Proxy</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> InternationalWeb <span class="token variable">$web</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">web</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$proxy</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Facebook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$proxy</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以拓展目标对象的功能</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li>缺点<ol><li>增加了系统的复杂度</li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-建造者模式</title>
      <link href="/2024/05/09/2024-05-2024-05-09-23-chong-she-ji-mo-shi-jian-zao-zhe-mo-shi/"/>
      <url>/2024/05/09/2024-05-2024-05-09-23-chong-she-ji-mo-shi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-建造者模式"><a href="#23种设计模式-建造者模式" class="headerlink" title="23种设计模式-建造者模式"></a>23种设计模式-建造者模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示</p><ul><li>分离了部件的构造和装配。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况</li><li>由于实现了构建和装配的解耦。不同的构建器、相同的装配，也可以做出不同的对象；想通的构建器、不同的装配顺序也可以做出不同的对象，也就是实现了构建算法、装配算法的解耦，实现了更好的复用</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无需知道其内部的具体构造细节</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>建造者模式包含如下角色：</p><ul><li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建</li><li>具体建造者类（ConcreteBuilder）：实现 <code>Builder</code> 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例</li><li>产品类（Product）：要创建的复杂对象</li><li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指挥者中不涉及具体产品的信息，只保证对象各个部分完整创建或按某种顺序创建</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 抽象建造者 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MobileBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$mobile</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token variable">$date</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">RedmiK70</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$date</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token variable">$date</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">date</span> <span class="token operator">=</span> <span class="token variable">$date</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">date</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">HuaweiNova12</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$date</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token variable">$date</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">date</span> <span class="token operator">=</span> <span class="token variable">$date</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">date</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体建造者 * 红米产品 */</span><span class="token keyword">class</span> <span class="token class-name">Redmi</span> <span class="token keyword">extends</span> <span class="token class-name">MobileBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置手机名称</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'红米K70'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDate</span><span class="token punctuation">(</span><span class="token string">'2023'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedmiK70</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Mobile    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体建造者 * 华为产品 */</span><span class="token keyword">class</span> <span class="token class-name">Huawei</span> <span class="token keyword">extends</span> <span class="token class-name">MobileBuilder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置手机名称</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'华为Nova12'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDate</span><span class="token punctuation">(</span><span class="token string">'2023'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HuaweiNova12</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Mobile    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">mobile</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 指挥者 */</span><span class="token keyword">class</span> <span class="token class-name">Director</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">build</span><span class="token punctuation">(</span>MobileBuilder <span class="token variable">$build</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$build</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$build</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$build</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$build</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-原型模式</title>
      <link href="/2024/05/09/2024-05-2024-05-09-23-chong-she-ji-mo-shi-yuan-xing-mo-shi/"/>
      <url>/2024/05/09/2024-05-2024-05-09-23-chong-she-ji-mo-shi-yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-原型模式"><a href="#23种设计模式-原型模式" class="headerlink" title="23种设计模式-原型模式"></a>23种设计模式-原型模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的clone方法</li><li>具体原型类：实现抽象原型类的clone方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的clone方法来复制新的对象</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 抽象原型类 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">account</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setAccount</span><span class="token punctuation">(</span><span class="token variable">$account</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">account</span> <span class="token operator">=</span> <span class="token variable">$account</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体原型类 */</span><span class="token keyword">class</span> <span class="token class-name">Xiaomi14</span> <span class="token keyword">extends</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO: Implement __clone() method.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$mobile</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Xiaomi14</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置账户</span><span class="token variable">$mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setAccount</span><span class="token punctuation">(</span><span class="token string">'ydz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 买了新手机</span><span class="token variable">$newMobile</span> <span class="token operator">=</span> clone <span class="token variable">$mobile</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 看看是谁的账户</span><span class="token keyword">echo</span> <span class="token variable">$newMobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 重新设置账户</span><span class="token variable">$newMobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setAccount</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 看看新手机账户是否修改</span><span class="token keyword">echo</span> <span class="token variable">$newMobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 看看旧手机账户</span><span class="token keyword">echo</span> <span class="token variable">$mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$newMobile</span> <span class="token keyword">instanceof</span>  <span class="token class-name">Xiaomi14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-抽象工厂模式</title>
      <link href="/2024/05/08/2024-05-2024-05-08-23-chong-she-ji-mo-shi-chou-xiang-gong-han-mo-shi/"/>
      <url>/2024/05/08/2024-05-2024-05-08-23-chong-she-ji-mo-shi-chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-抽象工厂模式"><a href="#23种设计模式-抽象工厂模式" class="headerlink" title="23种设计模式-抽象工厂模式"></a>23种设计模式-抽象工厂模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级产品的模式结构。</p><blockquote><p>产品族可以理解为，笔记本电脑，台式电脑都是电脑，所以他们算的上一个产品系列</p></blockquote><p>工厂模式里的工厂只生产同种类产品，比如汽车厂只生产汽车，但生活中很多工厂都是综合型的工厂，能生产不同种类的产品，比如电器厂既生产电视机又生产洗衣机等</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>抽象工厂模式的主要角色如下:</p><ul><li>抽象工厂： 提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品：定义了产品规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品：实现了抽象产品所定义的接口，由具体国产来创建，它同具体工厂之间是多对一的关系。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 抽象工厂 */</span><span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">RedmiK70</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'红米K70'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">RedmiBook</span> <span class="token keyword">implements</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'红米笔记本开机'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">HuaweiNova12</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'华为Nova12'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">XiaoxinBook</span> <span class="token keyword">implements</span> <span class="token class-name">Computer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'小心笔记本启动'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 华为系工厂 * 生产华为品牌产品，包含手机和电脑 */</span><span class="token keyword">class</span> <span class="token class-name">Huawei</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Mobile    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HuaweiNova12</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Computer    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">XiaoxinBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 小米系工厂 * 生产小米品牌产品，包含手机和电脑 */</span><span class="token keyword">class</span> <span class="token class-name">Xiaomi</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Mobile    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RedmiK70</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Computer    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RedmiBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：当一个产品系列中的多个对象呗设计成一起工作时，它能保证客户端始终只使用同一个产品系列的对象</p><p>缺点：当产品系列需要新增一个产品时，所有的工厂类都需要修改</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品系列时，如小米工厂中的手机、电脑等</li><li>系统中有多个产品系列，但每次只使用其中的某一系列产品，如有人只喜欢买小米品牌的产品</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-工厂模式</title>
      <link href="/2024/05/07/2024-05-2024-05-07-23-chong-she-ji-mo-shi-gong-han-mo-shi/"/>
      <url>/2024/05/07/2024-05-2024-05-07-23-chong-she-ji-mo-shi-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-工厂模式"><a href="#23种设计模式-工厂模式" class="headerlink" title="23种设计模式-工厂模式"></a>23种设计模式-工厂模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>工厂模式属于创建型模式，它定义一个用于创建对象的接口，让子类决定实例化哪个产品类的对象。工厂方法使一个产品类的实例化延迟到其工厂的子类</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>工厂模式的主要角色：</p><ul><li>抽象工厂 <code>AbstractFactory</code> ：提供了创建产品的接口，调用者通过它访问具体的工厂方法来创建产品</li><li>具体工厂 <code>ConcreteFactory</code> ：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</li><li>抽象产品 <code>Product</code> ：定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品 <code>ConcreteProduct</code> ：实现了抽象产品角色定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * 手机厂商接口 * 抽象工厂 */</span><span class="token keyword">interface</span> <span class="token class-name">MobileFactory</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 生产产品接口</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 手机产品接口 * 抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 红米K70 * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">RedmiK70</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'红米K70'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 华为Nova12 * 具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">HuaweiNova12</span> <span class="token keyword">implements</span> <span class="token class-name">Mobile</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'华为Nova12'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 华为手机厂商 * 具体工厂 */</span><span class="token keyword">class</span> <span class="token class-name">Huawei</span> <span class="token keyword">implements</span> <span class="token class-name">MobileFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HuaweiNova12</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 红米手机厂商 * 具体工厂 */</span><span class="token keyword">class</span> <span class="token class-name">Redmi</span> <span class="token keyword">implements</span> <span class="token class-name">MobileFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RedmiK70</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 测试工厂 */</span><span class="token keyword">class</span> <span class="token class-name">Shop</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">private</span> MobileFactory <span class="token variable">$factory</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">orderMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$mobile</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">factory</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token variable">$mobile</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实际调用</span><span class="token variable">$shop</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shop</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Huawei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$shop</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">orderMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式-单例模式</title>
      <link href="/2024/05/06/2024-05-2024-05-06-23-chong-she-ji-mo-shi-dan-li-mo-shi/"/>
      <url>/2024/05/06/2024-05-2024-05-06-23-chong-she-ji-mo-shi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式-单例模式"><a href="#23种设计模式-单例模式" class="headerlink" title="23种设计模式-单例模式"></a>23种设计模式-单例模式</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>单例模式是最简单的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>通常来说单例模式有以下步骤（<strong>三私一公</strong>）：</p><ul><li>构造函数私有化</li><li>克隆函数私有化</li><li>私有存放实例的静态成员属性</li><li>公有获取实例的函数，并且设为静态方法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 私有属性,保存实例</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造方法私有化，防止外部创建实例</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 业务属性</span>    <span class="token keyword">public</span> <span class="token variable">$attr</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 公有方法，对外提供获取实例途径</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断实例有无创建，有的话直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>            <span class="token operator">!</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$instance</span> <span class="token keyword">instanceof</span> <span class="token class-name">self</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">{</span>            self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$instance</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 克隆方法私有化，防止复制实例</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初窥SOLID设计原则</title>
      <link href="/2024/04/28/2024-04-2024-04-28-chu-kui-solid-she-ji-yuan-ze/"/>
      <url>/2024/04/28/2024-04-2024-04-28-chu-kui-solid-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="初窥SOLID设计原则"><a href="#初窥SOLID设计原则" class="headerlink" title="初窥SOLID设计原则"></a>初窥SOLID设计原则</h1><h2 id="为什么要使用设计原则"><a href="#为什么要使用设计原则" class="headerlink" title="为什么要使用设计原则"></a>为什么要使用设计原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可拓展性和灵活性，我们要尽量根据设计原则来开发程序，从而提高软件开发效率，节约软件开发成本和维护成本。</p><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>简单的来说就是一个类/接口/方法只负责一项职责</p><h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><p>软件实体应当对扩展开放，对修改关闭。简单来说就是<strong>尽量实现在新增功能的时候不修改已经写好的代码,实现一个热插拔的效果，类似于USB一样</strong></p><blockquote><p>个人理解：在根据业务设计模型对象时，可以不设计的那么完美，只按照需求设计对应的属性或方法即可，如新增需求的话，只需要继承原有对象，并实现需求，从而实现一个更细致化的模型</p></blockquote><h2 id="里式替换原则（LSP）"><a href="#里式替换原则（LSP）" class="headerlink" title="里式替换原则（LSP）"></a>里式替换原则（LSP）</h2><p>任何基类可以出现的地方，子类一定可以出现，通俗来讲：子类可以拓展父类的功能，但不能改变父类原有的功能，也就是说<strong>子类继承父类时，除添加新的方法完成新增功能时，尽量不要重写父类的方法</strong></p><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上，也就是说<strong>要为各个类建立他们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用</strong></p><p>单一职责原则主要是约束类，它针对的是程序中的实现和细节。接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建</p><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。总而言之就是<strong>要面向接口编程，不要面向实现编程</strong></p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p><strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用</strong>,可以通过第三方转发该调用。目的是为了降低类之间的耦合度，提高模块的相对独立性。</p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>在代码复用时，<strong>要尽量先试用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong></p><p>通常类的复用分为继承复用和合成复用两种</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性，因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为白箱复用</li><li>子类与父类的耦合度高，父类的实现有任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护</li><li>它限制了复用的灵活性，从父类继承过来的实现是静态的，在编译时就已经定义，所以在运行时不可能发生变化</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点</p><ol><li>它维持了类的封装性，因为成分对象的内部细节是新对象看不见的，所以这种复用又称为黑箱复用</li><li>对象间的耦合度低，可以在类的成员位置声明抽象</li><li>复用的灵活度高，这种复用可以在运动时动态进行，新对象可以动态的引入与成分对象相同的对象</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式的分类</title>
      <link href="/2024/04/27/2024-04-2024-04-27-23-chong-she-ji-mo-shi-de-fen-lei/"/>
      <url>/2024/04/27/2024-04-2024-04-27-23-chong-she-ji-mo-shi-de-fen-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式的分类"><a href="#23种设计模式的分类" class="headerlink" title="23种设计模式的分类"></a>23种设计模式的分类</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设计模式是一套被反复使用、多数人知晓的、经过分类编目、代码设计经验的总结，也是解决某类问题的最佳实践。</p><p>它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，他说解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确的使用设计模式具有下面优点</p><ul><li>可以提高我们的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码更加工程化、使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可复用性高、可读性强、可维护性强。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>创建型模式</strong></li></ul><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建和使用分离”。GoF书中提供了 <code>单例</code>、<code>原型</code>、 <code>工厂方法</code>、<code>抽象工厂</code>、<code>建造者</code>等4种创建型模式</p><ul><li><strong>结构型模式</strong></li></ul><p>用于描述“如何将类或对象按某种布局组成更大的结构”，GoF书中提供了 <code>代理</code>、<code>适配器</code>、<code>桥接</code>、<code>装饰</code>、<code>外观</code>、<code>享元</code>、<code>组合</code>等7种结构型模式</p><ul><li><strong>行为型模式</strong></li></ul><p>用于描述“类或对象之间怎么样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责”，GoF书中提供了<code>模版方法</code>、<code>策略</code>、<code>命令</code>、<code>职责链</code>、<code>状态</code>、<code>观察者</code>、<code>中介者</code>、<code>迭代器</code>、<code>访问者</code>、<code>备忘录</code>、<code>解释器</code>等11种行为型模式</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supervisor的快速入门</title>
      <link href="/2024/04/25/2024-04-2024-04-25-supervisor-de-kuai-su-ru-men/"/>
      <url>/2024/04/25/2024-04-2024-04-25-supervisor-de-kuai-su-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Supervisor的快速入门"><a href="#Supervisor的快速入门" class="headerlink" title="Supervisor的快速入门"></a>Supervisor的快速入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们的生产环境中，有些任务是不能停止的，否则业务就会收到影响，比如：python业务，redis队列等。那么如何保证这些服务的高可用呢？</p><p>那就需要使用守护进程了，比方说我们的进程运行挂掉之后自动恢复的功能，这些都能利用守护进程来实现。这之中使用比较常见的就是 <code>Supervisor</code>了，所以接下来介绍如何快速入门</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Supervisor</code> 是一个客户端/服务器系统，允许用户在类 <code>UNIX</code> 操作系统上控制多个进程。</p><p><code>Supervisor</code> 是用 <code>Python</code> 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p><p>它是通过 <code>fork/exec</code> 的方式把这些被管理的进程当作 <code>Supervisor</code> 的子进程来启动，这样只要在 <code>Supervisor</code> 的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。</p><p><code>Supervisor</code> 还提供了一个功能，可以为 <code>supervisord</code> 或者每个子进程，设置一个非 <code>root</code> 的 <code>user</code> ，这个 <code>user</code> 就可以管理它对应的进程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p><code>Ubuntu</code> 通过 <code>apt-get</code> 安装</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install supervisor</code></pre></li><li><p><code>Centos</code> 通过 <code>yun</code> 来安装</p><pre class=" language-shell"><code class="language-shell">yum install supervisor</code></pre></li><li><p><code>pip</code> 安装</p><pre class=" language-shell"><code class="language-shell">pip install supervisor</code></pre></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>Supervisor</code> 基础配置可以在 <code>/etc/supervisor/supervisord.conf</code> 进行配置</p><p>任务配置通常存放在 <code>/etc/supervisor/conf.d</code> 目录，在该目录下，可以创建多个配置文件指示 <code>Supervisor</code> 如何监视进程</p><h3 id="Supervisor-配置说明"><a href="#Supervisor-配置说明" class="headerlink" title="Supervisor 配置说明"></a>Supervisor 配置说明</h3><pre class=" language-php"><code class="language-php"><span class="token punctuation">[</span>unix_http_server<span class="token punctuation">]</span>file<span class="token operator">=</span><span class="token operator">/</span>tmp<span class="token operator">/</span>supervisor<span class="token punctuation">.</span>sock   <span class="token punctuation">;</span><span class="token constant">UNIX</span> socket 文件，supervisorctl 会使用<span class="token punctuation">;</span>chmod<span class="token operator">=</span><span class="token number">0700</span>                 <span class="token punctuation">;</span>socket文件的mode，默认是<span class="token number">0700</span><span class="token punctuation">;</span>chown<span class="token operator">=</span>nobody<span class="token punctuation">:</span>nogroup       <span class="token punctuation">;</span>socket文件的owner，格式：uid<span class="token punctuation">:</span>gid<span class="token punctuation">;</span><span class="token punctuation">[</span>inet_http_server<span class="token punctuation">]</span>         <span class="token punctuation">;</span><span class="token constant">HTTP</span>服务器，提供web管理界面<span class="token punctuation">;</span>port<span class="token operator">=</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">9001</span>        <span class="token punctuation">;</span>Web管理后台运行的<span class="token constant">IP</span>和端口，如果开放到公网，需要注意安全性<span class="token punctuation">;</span>username<span class="token operator">=</span>user              <span class="token punctuation">;</span>登录管理后台的用户名<span class="token punctuation">;</span>password<span class="token operator">=</span><span class="token number">123</span>               <span class="token punctuation">;</span>登录管理后台的密码<span class="token punctuation">[</span>supervisord<span class="token punctuation">]</span>logfile<span class="token operator">=</span><span class="token operator">/</span>tmp<span class="token operator">/</span>supervisord<span class="token punctuation">.</span>log <span class="token punctuation">;</span>日志文件，默认是 <span class="token variable">$CWD</span><span class="token operator">/</span>supervisord<span class="token punctuation">.</span>loglogfile_maxbytes<span class="token operator">=</span><span class="token constant">50MB</span>        <span class="token punctuation">;</span>日志文件大小，超出会rotate，默认 <span class="token constant">50MB</span>，如果设成<span class="token number">0</span>，表示不限制大小logfile_backups<span class="token operator">=</span><span class="token number">10</span>           <span class="token punctuation">;</span>日志文件保留备份数量默认<span class="token number">10</span>，设为<span class="token number">0</span>表示不备份loglevel<span class="token operator">=</span>info                <span class="token punctuation">;</span>日志级别，默认info，其它<span class="token punctuation">:</span> debug<span class="token punctuation">,</span>warn<span class="token punctuation">,</span>tracepidfile<span class="token operator">=</span><span class="token operator">/</span>tmp<span class="token operator">/</span>supervisord<span class="token punctuation">.</span>pid <span class="token punctuation">;</span>pid 文件nodaemon<span class="token operator">=</span><span class="token boolean">false</span>               <span class="token punctuation">;</span>是否在前台启动，默认是<span class="token boolean">false</span>，即以 daemon 的方式启动minfds<span class="token operator">=</span><span class="token number">1024</span>                  <span class="token punctuation">;</span>可以打开的文件描述符的最小值，默认 <span class="token number">1024</span>minprocs<span class="token operator">=</span><span class="token number">200</span>                 <span class="token punctuation">;</span>可以打开的进程数的最小值，默认 <span class="token number">200</span><span class="token punctuation">[</span>supervisorctl<span class="token punctuation">]</span>serverurl<span class="token operator">=</span>unix<span class="token punctuation">:</span><span class="token comment" spellcheck="true">///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><span class="token punctuation">;</span>serverurl<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><span class="token punctuation">;</span>包含其它配置文件 <span class="token punctuation">[</span><span class="token keyword">include</span><span class="token punctuation">]</span>files <span class="token operator">=</span> <span class="token operator">/</span>etc<span class="token operator">/</span>supervisor<span class="token operator">/</span>conf<span class="token punctuation">.</span>d<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>conf    <span class="token punctuation">;</span>这里也就是包含了我们的任务配置</code></pre><h3 id="任务配置说明"><a href="#任务配置说明" class="headerlink" title="任务配置说明"></a>任务配置说明</h3><pre><code>[program:nginx] #  设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名 我这里就叫做nginx了!command=/usr/sbin/php artisan queue:work --sleep=3;' # 需要执行的命令directory=/etc/nginx # 命令执行的目录或者说执行 command 之前，先切换到工作目录 可以理解为在执行命令前会切换到这个目录 在我这基本没啥用autostart=true #是否自动启动autorestart=true #程序意外退出是否自动重启redirect_stderr=true # 如果为true，则stderr的日志会被写入stdout日志文件中  理解为重定向输出的日志priority=10 # 启动优先级stdout_logfile=/data/logs/supervisord/nginx.log # 子进程的stdout的日志路径 输出日志文件stderr_logfile=/data/logs/supervisord/nginx.err.log # 错误日志文件 当redirect_stderr=true。这个就不用</code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre class=" language-shell"><code class="language-shell">supervisorctl reread # 重新读取配置supervisorctl update # 更新配置supervisorctl restart  # 重启supervisorctl status # 查看守护进程状态</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervisor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx日志统计分析常用命令</title>
      <link href="/2024/04/22/2024-04-2024-04-22-nginx-ri-zhi-tong-ji-fen-xi-chang-yong-ming-ling/"/>
      <url>/2024/04/22/2024-04-2024-04-22-nginx-ri-zhi-tong-ji-fen-xi-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Nginx访问日志中-按照ip请求次数统计命令（必备）"><a href="#1-Nginx访问日志中-按照ip请求次数统计命令（必备）" class="headerlink" title="1.Nginx访问日志中 按照ip请求次数统计命令（必备）"></a>1.Nginx访问日志中 按照ip请求次数统计命令（必备）</h3><pre><code>cat access.log |awk '{print $1}'|sort -nr |uniq -c |sort -nr |more   2761 183.185.117.4   1828 221.205.161.114   1672 223.12.67.104   1106 223.12.161.30    951 183.185.112.241    876 223.11.221.212    795 223.11.15.195    793 183.185.112.128</code></pre><h3 id="2-统计IP访问量（独立ip访问数量）"><a href="#2-统计IP访问量（独立ip访问数量）" class="headerlink" title="2.统计IP访问量（独立ip访问数量）"></a>2.统计IP访问量（独立ip访问数量）</h3><pre><code>awk '{print $1}' access.log | sort -n | uniq | wc -l</code></pre><h3 id="3-查看某一时间段的IP访问量-4-5点"><a href="#3-查看某一时间段的IP访问量-4-5点" class="headerlink" title="3.查看某一时间段的IP访问量(4-5点)"></a>3.查看某一时间段的IP访问量(4-5点)</h3><pre><code>grep "07/Apr/2017:0[4-5]" access.log | awk '{print $1}' | sort | uniq -c| sort -nr | wc -l  </code></pre><h3 id="4-查看访问最频繁的前100个IP-必备"><a href="#4-查看访问最频繁的前100个IP-必备" class="headerlink" title="4.查看访问最频繁的前100个IP(必备)"></a>4.查看访问最频繁的前100个IP(必备)</h3><pre><code>awk '{print $1}' access.log | sort -n |uniq -c | sort -rn | head -n 100</code></pre><h3 id="5-查看访问100次以上的IP"><a href="#5-查看访问100次以上的IP" class="headerlink" title="5.查看访问100次以上的IP"></a>5.查看访问100次以上的IP</h3><pre><code>awk '{print $1}' access.log | sort -n |uniq -c |awk '{if($1 &gt;100) print $0}'|sort -rn</code></pre><h3 id="6-查询某个IP的详细访问情况-按访问频率排序"><a href="#6-查询某个IP的详细访问情况-按访问频率排序" class="headerlink" title="6.查询某个IP的详细访问情况,按访问频率排序"></a>6.查询某个IP的详细访问情况,按访问频率排序</h3><pre><code>grep '127.0.01' access.log |awk '{print $7}'|sort |uniq -c |sort -rn |head -n 100</code></pre><h3 id="7-查看访问最频的页面-TOP100"><a href="#7-查看访问最频的页面-TOP100" class="headerlink" title="7.查看访问最频的页面(TOP100)"></a>7.查看访问最频的页面(TOP100)</h3><pre><code>awk '{print $7}' access.log | sort |uniq -c | sort -rn | head -n 100</code></pre><h3 id="8-查看访问最频的页面-排除php页面】-TOP100"><a href="#8-查看访问最频的页面-排除php页面】-TOP100" class="headerlink" title="8.查看访问最频的页面([排除php页面】(TOP100)"></a>8.查看访问最频的页面([排除php页面】(TOP100)</h3><pre><code>grep -v ".php"  access.log | awk '{print $7}' | sort |uniq -c | sort -rn | head -n 100 </code></pre><h3 id="9-查看页面访问次数超过100次的页面"><a href="#9-查看页面访问次数超过100次的页面" class="headerlink" title="9.查看页面访问次数超过100次的页面"></a>9.查看页面访问次数超过100次的页面</h3><pre><code>cat access.log | cut -d ' ' -f 7 | sort |uniq -c | awk '{if ($1 &gt; 100) print $0}' | less</code></pre><h3 id="10-查看最近1000条记录，访问量最高的页面"><a href="#10-查看最近1000条记录，访问量最高的页面" class="headerlink" title="10.查看最近1000条记录，访问量最高的页面"></a>10.查看最近1000条记录，访问量最高的页面</h3><pre><code>tail -1000 access.log |awk '{print $7}'|sort|uniq -c|sort -nr|less</code></pre><h3 id="11-统计每秒的请求数-top100的时间点-精确到秒"><a href="#11-统计每秒的请求数-top100的时间点-精确到秒" class="headerlink" title="11.统计每秒的请求数,top100的时间点(精确到秒)"></a>11.统计每秒的请求数,top100的时间点(精确到秒)</h3><pre><code>awk '{print $4}' access.log |cut -c 14-21|sort|uniq -c|sort -nr|head -n 100'</code></pre><h3 id="12-统计每分钟的请求数-top100的时间点-精确到分钟"><a href="#12-统计每分钟的请求数-top100的时间点-精确到分钟" class="headerlink" title="12.统计每分钟的请求数,top100的时间点(精确到分钟)"></a>12.统计每分钟的请求数,top100的时间点(精确到分钟)</h3><pre><code>awk '{print $4}' access.log |cut -c 14-18|sort|uniq -c|sort -nr|head -n 100</code></pre><h3 id="13-统计每小时的请求数-top100的时间点-精确到小时"><a href="#13-统计每小时的请求数-top100的时间点-精确到小时" class="headerlink" title="13.统计每小时的请求数,top100的时间点(精确到小时)"></a>13.统计每小时的请求数,top100的时间点(精确到小时)</h3><pre><code>awk '{print $4}' access.log |cut -c 14-15|sort|uniq -c|sort -nr|head -n 100</code></pre><h3 id="14-性能分析-在nginx-log中最后一个字段加入-request-time"><a href="#14-性能分析-在nginx-log中最后一个字段加入-request-time" class="headerlink" title="14.性能分析,在nginx log中最后一个字段加入$request_time"></a>14.性能分析,在nginx log中最后一个字段加入$request_time</h3><h4 id="列出传输时间超过-3-秒的页面，显示前20条"><a href="#列出传输时间超过-3-秒的页面，显示前20条" class="headerlink" title="列出传输时间超过 3 秒的页面，显示前20条"></a>列出传输时间超过 3 秒的页面，显示前20条</h4><pre><code>cat access.log|awk '($NF &gt; 3){print $7}'|sort -n|uniq -c|sort -nr|head -20</code></pre><h4 id="列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条"><a href="#列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条" class="headerlink" title="列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条"></a>列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条</h4><pre><code>cat access.log|awk '($NF &gt; 1 &amp;&amp;  $7~/\.php/){print $7}'|sort -n|uniq -c|sort -nr|head -100</code></pre><h3 id="15-统计蜘蛛抓取次数"><a href="#15-统计蜘蛛抓取次数" class="headerlink" title="15.统计蜘蛛抓取次数"></a>15.统计蜘蛛抓取次数</h3><pre><code>grep 'Baiduspider' access.log |wc -l</code></pre><h3 id="16-统计蜘蛛抓取404的次数"><a href="#16-统计蜘蛛抓取404的次数" class="headerlink" title="16.统计蜘蛛抓取404的次数"></a>16.统计蜘蛛抓取404的次数</h3><pre><code>grep 'Baiduspider' access.log |grep '404' | wc -l</code></pre><h3 id="17-TCP连接统计-查看当前TCP连接数"><a href="#17-TCP连接统计-查看当前TCP连接数" class="headerlink" title="17.TCP连接统计,查看当前TCP连接数"></a>17.TCP连接统计,查看当前TCP连接数</h3><pre><code>netstat -tan | grep "ESTABLISHED" | grep ":80" | wc -l</code></pre><h3 id="18-用tcpdump嗅探80端口的访问看看谁最高"><a href="#18-用tcpdump嗅探80端口的访问看看谁最高" class="headerlink" title="18.用tcpdump嗅探80端口的访问看看谁最高"></a>18.用tcpdump嗅探80端口的访问看看谁最高</h3><pre><code>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr</code></pre><h3 id="19-查询访问最频繁的IP-倒序排序列表"><a href="#19-查询访问最频繁的IP-倒序排序列表" class="headerlink" title="19. 查询访问最频繁的IP 倒序排序列表"></a>19. 查询访问最频繁的IP 倒序排序列表</h3><pre><code>awk '{print $1}' access*.log|sort | uniq -c |sort -n -k 1 -r|more</code></pre><h3 id="20-根据时间段统计查看日志"><a href="#20-根据时间段统计查看日志" class="headerlink" title="20. 根据时间段统计查看日志"></a>20. 根据时间段统计查看日志</h3><pre><code>cat access.log| sed -n '/14\/Mar\/2015:21/,/14\/Mar\/2015:22/p'|more</code></pre><h3 id="21-每秒客户端请求数-TOP5"><a href="#21-每秒客户端请求数-TOP5" class="headerlink" title="21. 每秒客户端请求数 TOP5"></a>21. 每秒客户端请求数 TOP5</h3><pre><code>awk  -F'[ []' '{print $5}' access.log|sort|uniq -c|sort -rn|head -5</code></pre><h3 id="22-访问最频繁IP-Top5"><a href="#22-访问最频繁IP-Top5" class="headerlink" title="22. 访问最频繁IP Top5"></a>22. 访问最频繁IP Top5</h3><pre><code>awk '{print $1}' access.log|sort |uniq -c | sort -rn |head -5</code></pre><h3 id="23-访问最频繁的URL-TOP5"><a href="#23-访问最频繁的URL-TOP5" class="headerlink" title="23. 访问最频繁的URL TOP5"></a>23. 访问最频繁的URL TOP5</h3><pre><code>awk '{print $7}' access.log|sort |uniq -c | sort -rn |head -5</code></pre><h3 id="24-响应大于10秒的URL-TOP5"><a href="#24-响应大于10秒的URL-TOP5" class="headerlink" title="24. 响应大于10秒的URL TOP5"></a>24. 响应大于10秒的URL TOP5</h3><pre><code>awk '{if ($12 &gt; 10){print $7}}' access.log|sort|uniq -c|sort -rn |head -5</code></pre><h3 id="25-HTTP状态码-非200-统计-Top5"><a href="#25-HTTP状态码-非200-统计-Top5" class="headerlink" title="25. HTTP状态码(非200)统计 Top5"></a>25. HTTP状态码(非200)统计 Top5</h3><pre><code>awk '{if ($13 != 200){print $13}}' access.log|sort|uniq -c|sort -rn|head -5</code></pre><h3 id="26-分析请求数大于50000的源IP的行为"><a href="#26-分析请求数大于50000的源IP的行为" class="headerlink" title="26. 分析请求数大于50000的源IP的行为"></a>26. 分析请求数大于50000的源IP的行为</h3><pre><code>awk '{print $1}' access.log|sort |uniq -c |sort -rn|awk '{if ($1 &gt; 50000){print $2}}' &gt; tmp.txt for i in $(cat tmp.txt) do  echo $i  &gt;&gt; analysis.txt   echo "访问行为统计" &gt;&gt; analysis.txt   grep $i  access.log|awk '{print $6}' |sort |uniq -c | sort -rn |head -5 &gt;&gt; analysis.txt   echo "访问接口统计" &gt;&gt; analysis.txt   grep $i  access.log|awk '{print $7}' |sort |uniq -c | sort -rn |head -5 &gt;&gt; analysis.txt   echo -e "\n"  &gt;&gt; /root/analysis/$Ydate.txt done</code></pre><blockquote><p>注：如果源IP来自代理服务器，应将第一条命令过滤地址改为$http_x_forwarded_for地址<br>awk ‘{print $NF}’ access.log|sort |uniq -c |sort -rn|awk ‘{if ($1 &gt; 50000){print $2}}’ &gt; tmp.txt</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php8的新特性(二) JIT</title>
      <link href="/2024/04/18/2024-04-2024-04-18-php8-de-xin-te-xing-er-jit/"/>
      <url>/2024/04/18/2024-04-2024-04-18-php8-de-xin-te-xing-er-jit/</url>
      
        <content type="html"><![CDATA[<h1 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/img/php-jit.webp" alt="jit编译原理图"></p><h3 id="Zend-Opcache流程"><a href="#Zend-Opcache流程" class="headerlink" title="Zend Opcache流程"></a>Zend Opcache流程</h3><ol><li>检查opcodes是否缓存</li><li>zend compiler编译器进行编译生成opcodes</li><li>optimizer优化器生成优化后的opcodes</li><li>把优化后的opcodes放入opcodes cache缓存</li><li>经过zend vm虚拟机生成opcodes handlers处理程序</li><li>送入x86 cpu架构进行执行</li></ol><h3 id="JIT编译流程"><a href="#JIT编译流程" class="headerlink" title="JIT编译流程"></a>JIT编译流程</h3><ol><li>检查opcodes是否缓存</li><li>zend compiler编译器进行编译生成opcodes</li><li>optimizer优化器生成优化后的opcodes</li><li>把优化后的opcodes放入opcodes cache缓存</li><li>jit编译器把optimized opcodes再次编译成汇编机器码machine codes</li><li>进入zend vm虚拟前先检查是否开启jit引擎</li><li>如果已经开启了jit引擎则直接读取机器码中的jit buffer代码片段</li><li>送入x86 cpu架构进行执行</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>JIT</code> 是基于 <code>Opcache</code> 之上的增强，是在 <code>Opcache</code> 优化后的基础上，结合 <code>Runtime</code> 的信息再次优化，直接生成机器码</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="开启功能"><a href="#开启功能" class="headerlink" title="开启功能"></a>开启功能</h3><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#php.ini</span>opcache<span class="token punctuation">.</span>jit<span class="token operator">=</span><span class="token number">1205</span>opcache<span class="token punctuation">.</span>jit_buffer_size<span class="token operator">=</span><span class="token constant">64M</span></code></pre><h3 id="opcache-jit参数说明"><a href="#opcache-jit参数说明" class="headerlink" title="opcache.jit参数说明"></a>opcache.jit参数说明</h3><h4 id="简单标记"><a href="#简单标记" class="headerlink" title="简单标记"></a>简单标记</h4><p>1.disable</p><blockquote><p>在启动时完全禁用JIT功能，并且在运行时无法启用</p></blockquote><p>2.off</p><blockquote><p>禁用，但是可以在运行时启用JIT</p></blockquote><p>3.on</p><blockquote><p>启用tracing模式</p></blockquote><p>4.tracing</p><blockquote><p>数值配置的别名1254</p></blockquote><p>5.function</p><blockquote><p>数值配置的别名1205</p></blockquote><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>1205每一位都是一个设置，从左至右开始依次介绍</p><ol><li><p>是否在生成机器码的时候使用AVX指令, 需要CPU支持</p><blockquote><p>0.不使用、1.使用</p></blockquote></li><li><p>寄存器分配策略</p><blockquote><p>0.不使用寄存器分配</p><p>1.局部(block)域分配</p><p>2.全局(function)域分配</p></blockquote></li><li><p>JIT触发策略</p><blockquote><p>0: PHP脚本载入的时候就JIT</p><p>1: 当函数第一次被执行时JIT</p><p>2: 在一次运行后，JIT调用次数最多的百分之(opcache.prof_threshold * 100)的函数</p><p>3: 当函数/方法执行超过N(N和opcache.jit_hot_func相关)次以后JIT</p><p>4: 当函数方法的注释中含有@jit的时候对它进行JIT</p><p>5: 当一个Trace执行超过N次（和opcache.jit_hot_loop, jit_hot_return等有关)以后JIT</p></blockquote></li><li><p>JIT优化策略，数值越大优化力度越大</p><blockquote><p>0: 不JIT</p><p>1: 做opline之间的跳转部分的JIT</p><p>2: 内敛opcode handler调用</p><p>3: 基于类型推断做函数级别的JIT</p><p>4: 基于类型推断，过程调用图做函数级别JIT</p><p>5: 基于类型推断，过程调用图做脚本级别的JIT</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> JIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php8的新特性(一) 主要新特性</title>
      <link href="/2024/04/15/2024-04-2024-04-15-php8-de-xin-te-xing-yi-zhu-yao-xin-te-xing/"/>
      <url>/2024/04/15/2024-04-2024-04-15-php8-de-xin-te-xing-yi-zhu-yao-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="php8的主要新特性"><a href="#php8的主要新特性" class="headerlink" title="php8的主要新特性"></a>php8的主要新特性</h1><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>声明$中的参数名称不带符号将是参数名称，或函数形参的名字取$后变为实参的命名函数</p><blockquote><p>格式：<code>name:"nickname"</code> 或 <code>name:$name</code></p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token variable">$nickname</span><span class="token punctuation">,</span> <span class="token variable">$avatar</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token string">"昵称为{$nickname}、头像为{$avatar}的用户"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">info</span><span class="token punctuation">(</span>avatar<span class="token punctuation">:</span><span class="token string">'avatar'</span><span class="token punctuation">,</span>nickname<span class="token punctuation">:</span><span class="token string">'nickname'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="可变参数下的应用"><a href="#可变参数下的应用" class="headerlink" title="可变参数下的应用"></a>可变参数下的应用</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">info</span> <span class="token punctuation">(</span><span class="token variable">$nickname</span><span class="token punctuation">,</span><span class="token variable">$avatar</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void<span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'nickname'</span><span class="token punctuation">,</span><span class="token string">'avatar'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">,</span>sex<span class="token punctuation">:</span><span class="token string">'man'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// array(2) { ["age"]=&gt; int(8) ["sex"]=&gt; string(3) "man" }</span></code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#[Name]</span><span class="token shell-comment comment">#[Name1,Name2]</span><span class="token shell-comment comment">#[Name(Arguments)]</span><span class="token shell-comment comment">#[Name(Argunment1,Arguments2,ArgumentN)]</span><span class="token shell-comment comment">#[Name1(Argument),Name2(Argument),Name3(Argument)]</span><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#[arg1]</span><span class="token shell-comment comment">#[arg2,arg3]</span><span class="token shell-comment comment">#[api(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token shell-comment comment">#[info(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'headimg'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token shell-comment comment">#[junp(</span><span class="token string">'跳'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token string">'跑'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">function</span> <span class="token function">show2</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">:</span>void<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token variable">$docRef</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReflectionFunction</span><span class="token punctuation">(</span><span class="token string">'show2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$docAttr</span> <span class="token operator">=</span> <span class="token variable">$docRef</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$docAttr</span> <span class="token keyword">as</span> <span class="token variable">$attrItem</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$attrItem</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$attrItem</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 打印结果: * string(4) "arg1" * array(0) { * } *  * string(4) "arg2" * array(0) { * } *  * string(4) "arg3" * array(0) { * } *  * string(3) "api" * array(1) { * [0]=&gt; * string(3) "123" * } *  * string(4) "info" * array(2) { * [0]=&gt; * string(4) "name" * [1]=&gt; * string(7) "headimg" * } *  * string(4) "junp" * array(1) { * [0]=&gt; * string(3) "跳" * } *  * string(3) "run" * array(1) { * [0]=&gt; * string(3) "跑" * } */</span></code></pre><h3 id="注解类的使用"><a href="#注解类的使用" class="headerlink" title="注解类的使用"></a>注解类的使用</h3><p>个人理解，使用注解可以将类定义成一个个低耦合、高内聚的元数据类，灵活的注入方法或者类里，通过反射注解类示例达到调用的目的</p><h3 id="注解类的使用示例"><a href="#注解类的使用示例" class="headerlink" title="注解类的使用示例"></a>注解类的使用示例</h3><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#[Attribute]</span><span class="token keyword">class</span> <span class="token class-name">initData</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">private</span> string <span class="token variable">$data</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">data</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token shell-comment comment">#[initData(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">class</span> <span class="token class-name">serviceData</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token variable">$classRef</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReflectionClass</span><span class="token punctuation">(</span><span class="token string">'serviceData'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$classAttr</span> <span class="token operator">=</span> <span class="token variable">$classRef</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token string">'initData'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$docClassObj</span> <span class="token operator">=</span> <span class="token variable">$classAttr</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$docClassObj</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><h2 id="构造器属性提升"><a href="#构造器属性提升" class="headerlink" title="构造器属性提升"></a>构造器属性提升</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>构造器属性提升是php8的一个新语法，允许从构造函数直接进行类属性声明和构造函数赋值。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 旧代码</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> string <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span>string <span class="token variable">$name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">name</span> <span class="token operator">=</span> <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 新代码</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> string <span class="token variable">$name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>低版本只能为属性、参数和返回类型声明单个类型。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> string <span class="token variable">$name</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword">public</span> string<span class="token operator">|</span><span class="token keyword">array</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>int<span class="token operator">|</span>string <span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>int<span class="token operator">|</span>string <span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">:</span>int<span class="token operator">|</span>string<span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Nullsafe空安全运算符"><a href="#Nullsafe空安全运算符" class="headerlink" title="Nullsafe空安全运算符"></a>Nullsafe空安全运算符</h2><p>这个特性就很棒了</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 旧版本用if判断，if地狱</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$session</span><span class="token operator">!==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$user</span> <span class="token operator">=</span> <span class="token variable">$session</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">user</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token operator">!==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$address</span> <span class="token operator">=</span> <span class="token variable">$user</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$address</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$country</span> <span class="token operator">=</span> <span class="token variable">$address</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">country</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$country</span><span class="token operator">!==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$country</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 新版本</span><span class="token keyword">echo</span> <span class="token variable">$session</span><span class="token operator">?</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">user</span><span class="token operator">?</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">country</span></code></pre><h2 id="Match表达式"><a href="#Match表达式" class="headerlink" title="Match表达式"></a>Match表达式</h2><p>感觉和switch差不多，但是执行严格匹配(===),然后匹配不到就会抛出错误 <code>UnhandledMatchError</code></p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><pre class=" language-php"><code class="language-php"><span class="token variable">$key</span> <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'a'</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">'this a'</span><span class="token punctuation">,</span>    <span class="token string">'c'</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">'this c'</span><span class="token punctuation">,</span>     <span class="token number">0</span>  <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">'this 0'</span><span class="token punctuation">,</span>    <span class="token string">'b'</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token string">'last b'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$str</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出 last b</span></code></pre><p>参考资料:<a href="https://www.kancloud.cn/cy0413/php8/2145902" target="_blank" rel="noopener">PHP8新特性技术详解2021版</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列之RabbitMQ(二) Laravel中使用rabbitmq</title>
      <link href="/2020/08/15/2020-08-2020-08-15-xiao-xi-dui-lie-zhi-rabbitmq-er-laravel-zhong-shi-yong-rabbitmq/"/>
      <url>/2020/08/15/2020-08-2020-08-15-xiao-xi-dui-lie-zhi-rabbitmq-er-laravel-zhong-shi-yong-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列之RabbitMQ-二-Laravel中使用rabbitmq"><a href="#消息队列之RabbitMQ-二-Laravel中使用rabbitmq" class="headerlink" title="消息队列之RabbitMQ(二) Laravel中使用rabbitmq"></a>消息队列之RabbitMQ(二) Laravel中使用rabbitmq</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>博主在之前的文章大致介绍了下 <code>rabbitmq</code> 的原理、应用场景。接下来讲下如何在 <code>laravel5.5</code> 中去使用。</p><h2 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h2><p>在本地进行测试的时候，使用 <code>docker</code> 去快速安装并检验预期结果是非常有效且合理的。因此本次将使用 <code>docker</code> 去构建 <code>rabbitmq</code>容器。</p><pre class=" language-sh"><code class="language-sh">docker run -d --hostname rabbit --name rabbit -p 5672:5672 -p 15672:15672 -p 25672:25672 rabbitmq:3.8.3-management</code></pre><p>大致介绍下上面参数</p><ul><li><code>--hostname</code> 设置该节点默认主机名</li><li><code>-- name</code>   设置容器名</li><li><code>-p</code> 指定端口映射。<code>5672:5672</code>意思是访问宿主机的5672端口的请求会被转发至容器的5672端口。在<code>rabbitmq</code>中，<code>5672</code>端口是程序用于访问<code>rabbitmq</code>的接口、<code>15672</code>则是<code>rabbitmq</code>自带的可视化UI管理界面的访问端口，可以通过在浏览器访问<code>localhost:15672</code>访问管理控制台、<code>25672</code>端口则被用于<code>rabbitmq</code>集群之间通讯使用</li><li><code>-v</code> 则是挂载目录或者文件，可以将宿主机的指定目录或者文件映射到容器里，这样宿主机和容器对该目录的操作会同步，防止了数据会因为容器的原因导致丢失。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="php安装amqp拓展"><a href="#php安装amqp拓展" class="headerlink" title="php安装amqp拓展"></a>php安装amqp拓展</h3><p>上文说到，<code>rabbitmq</code>是基于amqp协议的，因此在<code>laravel</code>中也是通过amqp协议去和<code>rabbitmq</code>程序进行通讯的，因此php需要安装amqp拓展。</p><pre class=" language-shell"><code class="language-shell">sudo apt-get updatesudo apt-get install php-amqp</code></pre><h2 id="Laravel中配置rabbitmq"><a href="#Laravel中配置rabbitmq" class="headerlink" title="Laravel中配置rabbitmq"></a>Laravel中配置rabbitmq</h2><p>博主在<code>laravel</code>中是使用 <code>laravel-queue-rabbitmq</code>包来实现和<code>rabbitmq</code>程序进行通讯的。</p><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>因为博主使用的是laravel5.5版本，所以<code>laravel-queue-rabbitmq</code>的版本是<code>6.0</code></p><ol><li>安装</li></ol><pre class=" language-shell"><code class="language-shell">composer require vladimir-yuldashev/laravel-queue-rabbitmq=6.0</code></pre><ol start="2"><li>在<code>config/app.php</code>文件中的<code>providers</code>中加入</li></ol><pre class=" language-php"><code class="language-php">VladimirYuldashev\<span class="token package">LaravelQueueRabbitMQ<span class="token punctuation">\</span>LaravelQueueRabbitMQServiceProvider</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span></code></pre><ol start="3"><li>在<code>app/config/queue.php</code>中的<code>connections</code>数组加入下面配置信息</li></ol><pre class=" language-php"><code class="language-php"><span class="token string">'rabbitmq'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>            <span class="token string">'driver'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'rabbitmq'</span><span class="token punctuation">,</span>            <span class="token string">'dsn'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_DSN'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/*             * Could be one a class that implements \Interop\Amqp\AmqpConnectionFactory for example:             *  - \EnqueueAmqpExt\AmqpConnectionFactory if you install enqueue/amqp-ext             *  - \EnqueueAmqpLib\AmqpConnectionFactory if you install enqueue/amqp-lib             *  - \EnqueueAmqpBunny\AmqpConnectionFactory if you install enqueue/amqp-bunny             */</span>            <span class="token string">'factory_class'</span> <span class="token operator">=</span><span class="token operator">></span> Enqueue\<span class="token package">AmqpLib<span class="token punctuation">\</span>AmqpConnectionFactory</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>            <span class="token string">'host'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_HOST'</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'port'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_PORT'</span><span class="token punctuation">,</span> <span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'vhost'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_VHOST'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'login'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_LOGIN'</span><span class="token punctuation">,</span> <span class="token string">'guest'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'password'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_PASSWORD'</span><span class="token punctuation">,</span> <span class="token string">'guest'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'queue'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE'</span><span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">'options'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>                <span class="token string">'exchange'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>                    <span class="token string">'name'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_NAME'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">/*                     * Determine if exchange should be created if it does not exist.                     */</span>                    <span class="token string">'declare'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_DECLARE'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">/*                     * Read more about possible values at https://www.rabbitmq.com/tutorials/amqp-concepts.html                     */</span>                    <span class="token string">'type'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_TYPE'</span><span class="token punctuation">,</span> \<span class="token package">Interop<span class="token punctuation">\</span>Amqp<span class="token punctuation">\</span>AmqpTopic</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">TYPE_DIRECT</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'passive'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_PASSIVE'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'durable'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_DURABLE'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'auto_delete'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_AUTODELETE'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'arguments'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_EXCHANGE_ARGUMENTS'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token string">'queue'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>                    <span class="token comment" spellcheck="true">/*                     * Determine if queue should be created if it does not exist.                     */</span>                    <span class="token string">'declare'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_DECLARE'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">/*                     * Determine if queue should be binded to the exchange created.                     */</span>                    <span class="token string">'bind'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_DECLARE_BIND'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token comment" spellcheck="true">/*                     * Read more about possible values at https://www.rabbitmq.com/tutorials/amqp-concepts.html                     */</span>                    <span class="token string">'passive'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_PASSIVE'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'durable'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_DURABLE'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'exclusive'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_EXCLUSIVE'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'auto_delete'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_AUTODELETE'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'arguments'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_QUEUE_ARGUMENTS'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/*             * Determine the number of seconds to sleep if there's an error communicating with rabbitmq             * If set to false, it'll throw an exception rather than doing the sleep for X seconds.             */</span>            <span class="token string">'sleep_on_error'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_ERROR_SLEEP'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/*             * Optional SSL params if an SSL connection is used             * Using an SSL connection will also require to configure your RabbitMQ to enable SSL. More details can be founds here: https://www.rabbitmq.com/ssl.html             */</span>            <span class="token string">'ssl_params'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>                <span class="token string">'ssl_on'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">'cafile'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL_CAFILE'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">'local_cert'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL_LOCALCERT'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">'local_key'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL_LOCALKEY'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">'verify_peer'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL_VERIFY_PEER'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token string">'passphrase'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string">'RABBITMQ_SSL_PASSPHRASE'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><ol start="4"><li>在项目根目录的<code>.env</code>文件配置如下环境变量</li></ol><pre><code>RABBITMQ_HOST=172.26.0.8 # 我是因为没有将rabbitmq容器加入lnmp的networks中，所以使用的是ipRABBITMQ_PORT=5672       # 和rabbitmq通讯的端口RABBITMQ_VHOST=/RABBITMQ_LOGIN=guest # 账号RABBITMQ_PASSWORD=guest # 密码RABBITMQ_QUEUE=test_queue # 队列名称。如果你没有它会默认创建 Exchanges和Queue</code></pre><ol start="5"><li>创建任务类<code>Job</code></li></ol><pre class=" language-shell"><code class="language-shell">php artisan make:job Queue</code></pre><p>执行之后在<code>app/Jobs/</code>目录下生成<code>Queue.php</code>文件，并写入对应逻辑</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Jobs</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Bus<span class="token punctuation">\</span>Queueable</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Queue<span class="token punctuation">\</span>SerializesModels</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Queue<span class="token punctuation">\</span>InteractsWithQueue</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Contracts<span class="token punctuation">\</span>Queue<span class="token punctuation">\</span>ShouldQueue</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Foundation<span class="token punctuation">\</span>Bus<span class="token punctuation">\</span>Dispatchable</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Queue</span> <span class="token keyword">implements</span> <span class="token class-name">ShouldQueue</span><span class="token punctuation">{</span>    <span class="token keyword">use</span> <span class="token package">Dispatchable</span><span class="token punctuation">,</span> InteractsWithQueue<span class="token punctuation">,</span> Queueable<span class="token punctuation">,</span> SerializesModels<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$uid</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$username</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Create a new job instance.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">,</span> <span class="token variable">$username</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">uid</span> <span class="token operator">=</span> <span class="token variable">$uid</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token variable">$username</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Execute the job.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'用户id ==='</span><span class="token punctuation">.</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">uid</span><span class="token punctuation">.</span><span class="token string">'。用户名 ==='</span><span class="token punctuation">.</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">username</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="6"><li>在控制器里派发任务，生产消息至队列中</li></ol><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Http<span class="token punctuation">\</span>Controllers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Http<span class="token punctuation">\</span>Request</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Foundation<span class="token punctuation">\</span>Bus<span class="token punctuation">\</span>DispatchesJobs</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Routing<span class="token punctuation">\</span>Controller</span> <span class="token keyword">as</span> BaseController<span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Foundation<span class="token punctuation">\</span>Validation<span class="token punctuation">\</span>ValidatesRequests</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Foundation<span class="token punctuation">\</span>Auth<span class="token punctuation">\</span>Access<span class="token punctuation">\</span>AuthorizesRequests</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Jobs<span class="token punctuation">\</span>Queue</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Controller</span> <span class="token keyword">extends</span> <span class="token class-name">BaseController</span><span class="token punctuation">{</span>    <span class="token keyword">use</span> <span class="token package">AuthorizesRequests</span><span class="token punctuation">,</span> DispatchesJobs<span class="token punctuation">,</span> ValidatesRequests<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">index</span><span class="token punctuation">(</span>Request <span class="token variable">$request</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$users</span> <span class="token operator">=</span> <span class="token punctuation">[</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'小明'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'小红'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'悟空'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'贝吉塔'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'盖伦'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'蛮王'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'uid'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'username'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'赵信'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$users</span> <span class="token keyword">as</span> <span class="token variable">$index</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$user</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$queue</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">[</span><span class="token string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$user</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$queue</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">onQueue</span><span class="token punctuation">(</span><span class="token string">'test_queue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token string">"OK!"</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们是可以在管理控制台看到Queue里被写入了7条<code>message</code></p><p><img src="https://s1.ax1x.com/2020/08/15/dk47YF.jpg" alt="message"></p><ol start="7"><li>开启队列并消费它</li></ol><pre class=" language-shell"><code class="language-shell">php artisan queue:work rabbitmq --queue=test_queue --tries=3</code></pre><p>可以看到之前生产的7条数据已经被消费了</p><p><img src="https://s1.ax1x.com/2020/08/15/dk5Kfg.jpg" alt="message2"></p><p>其他的信息我们可以去管理控制台里查看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中联合查询的一些优化感悟</title>
      <link href="/2020/08/02/2020-08-2020-08-02-mysql-zhong-lian-he-cha-xun-de-yi-xie-you-hua-gan-wu/"/>
      <url>/2020/08/02/2020-08-2020-08-02-mysql-zhong-lian-he-cha-xun-de-yi-xie-you-hua-gan-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL中联合查询的一些优化感悟"><a href="#MySQL中联合查询的一些优化感悟" class="headerlink" title="MySQL中联合查询的一些优化感悟"></a>MySQL中联合查询的一些优化感悟</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天博主在left join的SQL语句优化中发现了一个奇怪的现象，随后在网上查阅了相关资料，现在复盘并记录下来。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>现在有 <code>data_users</code> 以及 <code>data_posts</code> 两张表。</p><p><code>data_users</code> 表中有主键索引<code>id</code>。 <code>data_posts</code> 表中索引 <code>uid</code>，uid是外键。</p><p>现在有如下SQL语句:</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> data_users <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> data_posts <span class="token keyword">on</span> data_users<span class="token punctuation">.</span>id <span class="token operator">=</span> data_posts<span class="token punctuation">.</span>uid<span class="token punctuation">;</span></code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYYm1x.jpg" alt="sql结果"></p><p>可以看到上面结果，左表是没有命中索引的，所以进行了全表扫描。右表因为 <code>uid</code> 建立了索引，最后命中了索引，但是这样的效率其实比较低的，特别是在两张表数据量规模大的时候，他所扫描的基本是是左表的总行数和右表的查询结果的笛卡尔积。</p><p>接下来我们改下sql语句。</p><pre class=" language-$xslt"><code class="language-$xslt">select * from data_users JOIN data_posts on data_users.id = data_posts.uid;</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYtvQ0.jpg" alt="sql结果2"></p><p>可以看到上面结果都命中了索引，这样效率得到了大大的提升。</p><p>那么除了这种改动之外，我对第一个sql语句中做另外的改变，得到第二个优化后的语句。</p><pre class=" language-$xslt"><code class="language-$xslt">select * from data_users LEFT JOIN data_posts on data_users.id = data_posts.uid where data_users.id = 1;</code></pre><p><img src="https://s1.ax1x.com/2020/08/02/aYN0Yj.jpg" alt="sql结果3"></p><p>可以看到上面的查询结果也全都命中了索引，那么这其中的原理究竟为何呢？</p><h2 id="MySQL中join的原理"><a href="#MySQL中join的原理" class="headerlink" title="MySQL中join的原理"></a>MySQL中join的原理</h2><p>在网上查询了mysql实现join的原理，原来 <code>MySQL</code> 内部采用了一种叫做 <code>nested loop join</code>的算法，该算法就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与了join，则再通过前两个表的结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复，基本上Mysql采取容易理解的算法来实现join。所以驱动表的选择非常重要，驱动表的数据量小可以显著降低扫描的行数。</p><p>那么为什么一版情况下join的效率要高于left join很多呢，其实一般情况下参与联合查询的两张表都会一大一小，如果是join，在没有其他过滤条件的情况下，会选择用小表作为驱动表，但是left join一般因为本身的特性决定了会用大表做驱动表，这样下来效率就差了不少。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在了解join的基本原理后，在我们使用join后，mysql会使用 <code>data_posts</code>的结果集作为驱动表，而该结果集已经命中了索引，因此效率得到了显著的提升。</p><p>而第二个优化后的sql语句，因为加了where子句，虽然因为left join的特性，选择了大表 <code>data_users</code>作为驱动表，但本身经过过滤后，数量大大减少且命中了索引。因此该语句的效率也得到了显著的提升。</p><p>参考资料: <a href="https://www.cnblogs.com/weizhenlu/p/5970392.html" target="_blank" rel="noopener">mysql join 和left join 对于索引的问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 查询优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列之RabbitMQ(一) 介绍、核心概念、交换器类型</title>
      <link href="/2020/07/30/2020-07-2020-07-30-xiao-xi-dui-lie-zhi-rabbitmq-yi-jie-shao-he-xin-gai-nian-jiao-huan-qi-lei-xing/"/>
      <url>/2020/07/30/2020-07-2020-07-30-xiao-xi-dui-lie-zhi-rabbitmq-yi-jie-shao-he-xin-gai-nian-jiao-huan-qi-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列之RabbitMQ-一-介绍、核心概念、交换器类型"><a href="#消息队列之RabbitMQ-一-介绍、核心概念、交换器类型" class="headerlink" title="消息队列之RabbitMQ(一) 介绍、核心概念、交换器类型"></a>消息队列之RabbitMQ(一) 介绍、核心概念、交换器类型</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>博主在介绍 <code>RabbitMQ</code> 之前有必要说说消息队列是什么？</p><p>消息是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以很复杂，可能包含嵌入对象。</p><p>消息队列是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者（生产者）只管把消息发布到MQ中而不用管谁来取，消息使用者（消费者）只管从MQ中取消息而不管消息是谁发布的。这样发布者和使用者都不用知道对方的存在，这样就形成了应用间的解耦。</p><p>目前主流的消息队列是 <code>RabbitMQ</code> 、 <code>Kafka</code> 。当然 <code>Redis</code>也能当做轻量级的消息队列。</p><h3 id="消息队列典型的应用场景"><a href="#消息队列典型的应用场景" class="headerlink" title="消息队列典型的应用场景"></a>消息队列典型的应用场景</h3><ul><li>异步处理： 把消息放入消息中间件中，等到需要的时候再去使用。</li><li>流量削峰： 例如秒杀活动，在短时间内访问量急剧增加，使用消息队列，当消息队列满了后就拒绝响应，这样就使得系统达到一定并发后不会因为超负载而崩溃。</li><li>日志处理:  在分布式系统中，每个节点应用都会产生日志，一旦集群规模庞大。日志系统也将面临大并发的尴尬局面。因此可以在日志收集后推送到队列里，再由日志系统去消费存储。</li><li>应用解耦:  假设某个服务A需要给许多个服务(B，C，D)发送消息，当服务B不需要发送消息了，服务A需要修改代码重新部署，新加入一个服务E需要服务A的消息时，也需要修改代码重新部署。这样对于整个系统而言，他的拓展性是十分不足的，但是使用MQ发布订阅模式后，服务A作为生产者，而其他的应用只需作为消费者去消费队列里的消息，这样就会使得应用之间解耦。大大的提高了系统的拓展性。</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><code>RabbitMQ</code> 是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。<br><code>RabbitMQ</code> 是使用Erlang语言来编写，并且 <code>RabbitMQ</code> 是基于AMQP协议。Erlang于洋在数据交互方面性能优秀，有着和原生Socket一样的延迟，这也是 <code>RabbitMQ</code> 高性能的原因所在。</p><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p>AMQP协议是具有现代特征的二进制协议。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p><h2 id="常用交换器"><a href="#常用交换器" class="headerlink" title="常用交换器"></a>常用交换器</h2><p>交换器，接受消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。</p><p><code>RabbitMQ</code> 常用的交换器类型由direct、topic、fanout、headers四种。</p><ol><li><p>Direct交换器：该类型的交换器将所有发送到该交换器的消息被转发到RoutingKey指定的队列中，也就是路由到BindKey和RoutingKey完全匹配的队列中</p></li><li><p>Topic交换器：该类型的交换器将所有发送到Topic Exchange的消息被转发到所有RoutingKey指定的Topic队列上面。交换器会将Routingkey和某Topic进行模糊匹配，其中<code>""</code>用来匹配一个词，<code>"#"</code>用于匹配一个或者多个词。例如<code>"com.#""</code>能匹配到<code>"com.rabbitmq.oa"</code>和<code>"com.rabbitmq"</code>而<code>"login."</code>只能匹配到<code>"com.rabbitmq"</code></p></li><li><p>Fanout交换器: 该类型不处理RoutingKey，会把所有发送到交换器的消息路由到所有绑定的队列中。优点是转发消息最快，性能最好。</p></li><li><p>Headers交换器： 该类型交换器不依赖路由规则来路由消息，而是根据消息内容中的headers属性进行匹配。headers类型交换器性能差，在实际中并不常用。</p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>上面是博主总结的RabbitMQ的基本原理和需要掌握的基础知识，后面将会介绍如何安装以及使用入门。</p><p>参考资料:<a href="https://www.cnblogs.com/sgh1023/p/11217017.html" target="_blank" rel="noopener">RabbitMQ（一）：RabbitMQ快速入门</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记(一)-什么是Docker?</title>
      <link href="/2020/07/13/2020-07-2020-07-13-docker-xue-xi-bi-ji-yi-shi-me-shi-docker/"/>
      <url>/2020/07/13/2020-07-2020-07-13-docker-xue-xi-bi-ji-yi-shi-me-shi-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h3 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么?"></a>docker是什么?</h3><ul><li><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。</p></li><li><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p></li><li><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p></li></ul><h3 id="为什么需要docker"><a href="#为什么需要docker" class="headerlink" title="为什么需要docker"></a>为什么需要docker</h3><ul><li>因为环境配置不同，很多人在开发中也会遇到这个情况，甚至开发的软件到了测试人员的机器上便不能运行。但这都不是重点。重点是，如果我们有一个可靠的、可分发的标准开发环境，那么我们的开发将不会像现在这么痛苦。Docker 便可以解决这个问题。Docker 镜像并不会因为环境的变化而不能运行，也不会在不同的电脑上有不同的运行结果。可以给测试人员提交含有应用的 Docker 镜像，这样便不再会发生“在我机器上是可以运行的”这种事情，很大程度上减轻了开发人员测试人员互相检查机器环境设置带来的时间成本。</li><li>作为一个程序员，新技术的迭代周期也十分短暂，因此快速学习一门新技术就很重要，其中如何快速的搭建新技术的开发环境就显得特别重要，当我们花费几周甚至一个月磕磕碰碰的搭建好一个不是很成熟但是能使用的开发环境的时候，使用docker搭建环境可能只需要一行命令，就能搭建起一个成熟的最佳配置的开发环境</li></ul><h3 id="docker的原理"><a href="#docker的原理" class="headerlink" title="docker的原理"></a>docker的原理</h3><h4 id="形象的说，docker就是集装箱原理"><a href="#形象的说，docker就是集装箱原理" class="headerlink" title="形象的说，docker就是集装箱原理"></a>形象的说，docker就是集装箱原理</h4><ul><li><p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p></li><li><p>docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。</p></li></ul><h3 id="docker的优点"><a href="#docker的优点" class="headerlink" title="docker的优点"></a>docker的优点</h3><ol><li><p><strong>简化程序</strong>：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的    任务，在Docker容器的处理下，只需要数秒就能完成。</p></li><li><p><strong>避免选择恐惧症</strong>：<br>如果你有选择恐惧症，还是资深患者。Docker 帮你    打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p></li><li><p><strong>节省开支</strong>：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p><h3 id="docker的应用场景"><a href="#docker的应用场景" class="headerlink" title="docker的应用场景"></a>docker的应用场景</h3></li></ol><ul><li>使应用的打包与部署自动化</li><li>创建轻量、私密的PAAS环境</li><li>实现自动化测试和持续的集成/部署</li><li>部署与扩展webapp、数据库和后台服务<h3 id="docker的局限"><a href="#docker的局限" class="headerlink" title="docker的局限"></a>docker的局限</h3></li><li>Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用</li><li>LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的</li><li>隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库</li><li>网络管理相对简单，主要是基于namespace隔离</li><li>cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费)</li><li>Docker对disk的管理比较有限</li><li>container随着用户进程的停止而销毁，container中的log等用户数据不便收集</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel核心 - 门面Facades</title>
      <link href="/2020/07/12/2020-07-2020-07-12-larave-he-xin-men-mian-facades/"/>
      <url>/2020/07/12/2020-07-2020-07-12-larave-he-xin-men-mian-facades/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel的门面Facades是什么"><a href="#Laravel的门面Facades是什么" class="headerlink" title="Laravel的门面Facades是什么"></a>Laravel的门面Facades是什么</h1><p>门面为应用服务容器的绑定类提供了一个静态接口。Laravel内置了很多门面，你可能在不知道的情况下正在使用它们。laravel的门面作为服务容器中低层类的静态代理，相比于传统静态方法，在维护时能够提供易于测试、更加灵活、简明优雅的语法。</p><h1 id="何时使用门面Facades"><a href="#何时使用门面Facades" class="headerlink" title="何时使用门面Facades"></a>何时使用门面Facades</h1><p>门面有许多优点，其提供了简单易记的语法，让我妈无需记住长长的类名即可使用laravel提供的功能特性，此外，由于他们对php动态方法的独到用法，使得他们很容易测试。</p><p>但是使用门面也有需要注意的地方,一个最主要的危险就是类范围蠕变。由于门面如此好用并且不需要注入，在单个类中使用过多门面，会让类很容易变得越来越大。使用依赖注入则会让此类问题缓解，因为一个巨大的构造函数会让我们很容易判断类在变大。因此，使用门面的时候尤其注意类的大小，一遍控制其有限职责</p><h1 id="门面的工作原理"><a href="#门面的工作原理" class="headerlink" title="门面的工作原理"></a>门面的工作原理</h1><p>门面工作原理分为两步,</p><ol><li><p>第一步是编写门面类</p><pre><code>class Cache extends Facade{ /**  * 获取组件注册名称  *  * @return string  */ protected static function getFacadeAccessor() {      return 'cache';  }}</code></pre><p>他会通过服务容器绑定的接口名获取对应类的实例</p></li><li><p>他会调用魔术方法__callStatic，通过这个魔术方法实现调用静态方法去调用实例的动态方法</p><pre><code> /**  * Handle dynamic, static calls to the object.  *  * @param  string  $method  * @param  array   $args  * @return mixed  *  * @throws \RuntimeException  */ public static function __callStatic($method, $args) {     //通过第一步获取到的服务容器实例     $instance = static::getFacadeRoot();     if (! $instance) {         throw new RuntimeException('A facade root has not been set.');     }     //调用实例的动态方法     return $instance-&gt;$method(...$args); }</code></pre></li></ol><p><strong>总的来说</strong>:在laravel应用阿忠，门面就是一个为容器中对象提供访问方式的类。该机制原理由Facade类实现。laravel自带的门面，以及我们创建的自定义门面，都会继承自<code>Illuminate\Support\Facades\Facade</code> 基类.</p><p>门面类只需要实现一个方法:<code>getFacadeAccessor</code>。正是这个方法定义了从容器中解析什么，然后Facade基类使用魔术方法__callStatic从你的门面调用解析对象.</p><h1 id="实时门面-不需要自己编写相对应的门面类，有laravel自己去动态解析获取对应的类"><a href="#实时门面-不需要自己编写相对应的门面类，有laravel自己去动态解析获取对应的类" class="headerlink" title="实时门面(不需要自己编写相对应的门面类，有laravel自己去动态解析获取对应的类"></a>实时门面(不需要自己编写相对应的门面类，有laravel自己去动态解析获取对应的类</h1><blockquote><p>个人理解:相当于省去了第一个步骤，我们创建门面类告诉laravel应用应该从服务容器解析什么，直接通过命名空间自动的解析对应类的实例</p></blockquote><pre><code>&lt;?phpnamespace Tests\Feature;use App\Podcast;use Tests\TestCase;use Facades\App\Contracts\Publisher;use Illuminate\Foundation\Testing\RefreshDatabase;class PodcastTest extends TestCase{    use RefreshDatabase;    /**     * A test example.     *     * @return void     */    public function test_podcast_can_be_published()    {        $podcast = factory(Podcast::class)-&gt;create();        Publisher::shouldReceive('publish')-&gt;once()-&gt;with($podcast);        $podcast-&gt;publish();    }}</code></pre><p>上面例子，我们通过命名空间<code>use Facades\App\Contracts\Publisher;</code>告诉应用我们要使用实时的门面类，通过字符串处理,将App\Contracts\Publisher通过服务容器解析，然后交由门面.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel核心 - 服务容器</title>
      <link href="/2020/07/11/2020-07-2020-07-11-larave-he-xin-fu-wu-rong-qi/"/>
      <url>/2020/07/11/2020-07-2020-07-11-larave-he-xin-fu-wu-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel的服务容器是什么"><a href="#Laravel的服务容器是什么" class="headerlink" title="Laravel的服务容器是什么"></a>Laravel的服务容器是什么</h1><p>laravel的服务容器是用于管理类的依赖和执行依赖注入的工具。依赖注入实质上是指：类的依赖项通过构造函数或者某些情况下通过setter方法注入到类中</p><blockquote><p>setter就是类似魔术方法__set的方法，也可以自定义</p></blockquote><blockquote><p>服务容器的核心功能是IoC容器用以解决依赖注入，控制反转 IoC模式又称依赖注入模式</p></blockquote><blockquote><p>依赖注入是指组件的依赖通过外部以参数或其他形式注入</p></blockquote><h1 id="为什么使用服务容器"><a href="#为什么使用服务容器" class="headerlink" title="为什么使用服务容器"></a>为什么使用服务容器</h1><p>使用这种方式，一方面降低了代码之间的耦合，另一方面也提高了代码的可维护性与拓展性</p><h1 id="服务容器的应用场景"><a href="#服务容器的应用场景" class="headerlink" title="服务容器的应用场景"></a>服务容器的应用场景</h1><h3 id="类似发邮件服务的全局服务"><a href="#类似发邮件服务的全局服务" class="headerlink" title="类似发邮件服务的全局服务"></a>类似发邮件服务的全局服务</h3><p>我们把发送邮件的功能封装成一个类，需要使用的时候，实例化并调用发送方法<br>下面是php代码的简单实现</p><pre><code>/** *发送邮件服务类 */class EmailService{    public function send(){        //todo 发送邮件方法    }}//如果任何地方要发邮件我们就复制下面这两行代码$emailService = new EmailService();$emailService-&gt;send();</code></pre><p>但是使用了laravel的服务容器之后</p><pre><code>$this-&gt;app-&gt;bind('emailService', function ($app) {    return new EmailService();});//如果任何地方要发邮件我们就复制下面这两行代码$emailService = app('emailService');$emailService-&gt;send();</code></pre><p>这就使我们的代码更加简洁了，由于有了中间层，灵活性提高了，那么无论测试或者优化我们的服务类都会变得更方便</p><pre><code>//只需要改这一个地方$this-&gt;app-&gt;bind('emailService', function ($app) {    return new SupperEmailService();});</code></pre><p>其他调用的地方我们完全不用动，如果我们没有这个绑定操作(中间层),那么我们不得不在每个使用服务的地方进行修改，这样就会很繁琐.</p><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>还是使用上面的邮件服务例子，可能处于性能的考虑，需要这个服务实现单例模式,于是在不适用laravel服务容器的情况下，做出如下更改</p><pre><code>class SupperEamilService{      //创建静态私有的变量保存该类对象     static private $instance;      //防止直接创建对象      private function __construct(){     }         //防止克隆对象     private function __clone(){     }     static public function getInstance(){                 //判断$instance是否是Uni的对象                 //没有则创建         if (!self::$instance instanceof self) {             self::$instance = new self();         }         return self::$instance;     }     //发送邮件方法     public function send(){     } }</code></pre><p>除此之外，由于服务类的构造函数为私有，无法通过new关键字来实例化对象，所以在每个实例化的地方调用都需要改成这样</p><pre><code>$emailService=SupperEmailService::getInstance();$emailService-&gt;send();</code></pre><p>但是laravel的服务容器天生支持单例</p><pre><code>//只需要把bind改成singleton $this-&gt;app-&gt;singleton('emailService', function ($app) {    return new SupperEmailService();});</code></pre><p>我们只需要把原来的bind方法改成singleton,通过容器取出来的就是单例了</p><h3 id="旅行者去旅行"><a href="#旅行者去旅行" class="headerlink" title="旅行者去旅行"></a>旅行者去旅行</h3><p>这个例子就是讲旅行和旅行工具之间的服务解耦.</p><p>假设一个旅行者去西藏旅行，可以坐火车或者走路去</p><p>不使用laravel服务容器:</p><pre><code>&lt;?phpinterface TrafficTool{  public function go();}class Train implements TrafficTool{  public function go()  {  echo "train....";  }}class Leg implements TrafficTool{  public function go()  {  echo "leg..";  }}class Traveller{  /**  * @var Leg|null|Train  * 旅行工具  */  protected $_trafficTool;  public function __construct(TrafficTool $trafficTool)  {  $this-&gt;_trafficTool = $trafficTool;  }  public function visitTibet()  {  $this-&gt;_trafficTool-&gt;go();  }}</code></pre><p>当旅行者要坐或者去旅行，通常我们这样写</p><pre><code>&lt;?php $train = new Train();$tra = new Traveller($train);$tra-&gt;visitTibet();</code></pre><p>事实上这种写法非常不错了，因为对于旅行工具的依赖已经通过接口的方式转移到外部了。但是使用new来实例化的时候还是会产生依赖。也就是说Train和Traveller之间产生了耦合</p><p>那么laravel服务容器怎么实现的?</p><pre><code>&lt;?phpnamespace App\Providers;use Laravel\Lumen\Providers\EventServiceProvider as ServiceProvider;class RepositoryServiceProvider extends ServiceProvider{  public function register()  {     //在服务容器中绑定类     $this-&gt;app-&gt;bind( 'TrafficTool', 'Train');     $this-&gt;app-&gt;bind('Traveller', 'Traveller');  }}</code></pre><p>实例化对象</p><pre><code>&lt;?php// 实例化对象$tra = app()-&gt;make('Traveller');$tra-&gt;visitTibet(); </code></pre><p>当我们使用服务容器获取旅行类的对象时，容器会自动注入对象所需要的参数，而在此之前我只需要绑定特定的类就可以了，这样才体现了真正的自动化，是的旅行和旅行工具完全解耦了，当我们需要更改旅行方式的时候，只需要更改绑定就好了</p><p>参考资料:<br><a href="https://xiaoxingping.top/blog/3/shi-yong-laravel-fu-wu-rong-qi-de-you-shi" target="_blank" rel="noopener">使用laravel服务容器的优势</a></p><h3 id="应用场景的总结"><a href="#应用场景的总结" class="headerlink" title="应用场景的总结"></a>应用场景的总结</h3><p>1,应用于服务之间的解耦<br>2,方便的实现单例模式</p><h1 id="服务容器原理"><a href="#服务容器原理" class="headerlink" title="服务容器原理"></a>服务容器原理</h1><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>laravel服务容器的一个强大的特性就是能通过反射自动解析依赖。反射具有检测类及其方法的能力,比如PHP中的ReflectionClass类允许你检测一些方法在给定的类中是否可用.</p><p>通过PHP的这种特性，laravel可以实现一些有趣的功能!</p><pre><code>class UserController extends BaseController {    public function __construct(StripeBiller $biller)    {        $this-&gt;biller = $biller;    }}</code></pre><p>如上控制器初始化时需要传入StripeBiller类型的对象，我们可以通过反射进行类型检测。当laravel容器没有绑定相应的解析器，他就会通过反射尝试解析该类.流程大致如下</p><ol><li>服务容器有无StripeBiiler解析器？（就是是否在服务容器绑定过）</li><li>没有解析器？映射类StripeBiller判断其依赖</li><li>递归的解析StripeBiller类的所有依赖</li><li>通过ReflectionClass-&gt;newInstanceArgs()实例化一个新的StripeBiller<br>可以看到服务容器为我们做了许多繁重的工作，使你能释放更多时间用于编码各种逻辑的代码类。<blockquote><p>掌握容器，先查看下容器的源码IlluminateContainerContainer这个类文件</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置反向代理</title>
      <link href="/2020/07/08/2020-07-2020-07-08-nginx-pei-zhi-fan-xiang-dai-li/"/>
      <url>/2020/07/08/2020-07-2020-07-08-nginx-pei-zhi-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的lnamp的nginx反向代理转发"><a href="#简单的lnamp的nginx反向代理转发" class="headerlink" title="简单的lnamp的nginx反向代理转发"></a>简单的lnamp的nginx反向代理转发</h1><p>访问站点由nginx服务器接受请求并转发给局域网里的某台lamp的服务器。</p><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><p>1，正常的部署一台nginx服务器以及一台lamp服务器，他们在一个局域网里面，然后再nginx服务器里面的nginx的配置文件里面修改</p><pre><code>location / {    proxy set header X-Real-IP $remote_addr;    proxy set header Host $http_host;    proxy_pass https://ws:1000;    client_max_body_size 35m;    proxy_http_version 1.1;}</code></pre><blockquote><p>记得将location里面的index等默认访问文件给注释掉,不然还是会正常访问默认文件</p></blockquote><ol><li>如果你的nginx服务器配置了https证书，那么你的客户端到服务器端之间的连接是加密的，虽然你nginx转发了请求，但是客户在浏览器看到的还是https证书</li><li>通常情况下服务器与服务器之间是在一个私有云的局域网内，所以在性能吃紧的情况下，服务器和服务器之间是不需要配置https的。</li><li>如果想转发长连接也就是websocket，还需要在配置文件里加几行代码</li></ol><p><code>proxy set header Upgrade $http_upgrade</code></p><p><code>proxy set header Connection "upgrade"</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow 工作流规范的使用</title>
      <link href="/2020/07/07/2020-07-2020-07-07-gitflow-gong-zuo-liu-gui-fan-de-shi-yong/"/>
      <url>/2020/07/07/2020-07-2020-07-07-gitflow-gong-zuo-liu-gui-fan-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Flow工作流规范的使用"><a href="#Git-Flow工作流规范的使用" class="headerlink" title="Git Flow工作流规范的使用"></a>Git Flow工作流规范的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常在我们的项目开发过程中，在版本控制流程里没有一个规范去约束，往往会导致git的分支混乱，以及难以管理的问题发生，因此为了规避这些问题的产生，我们也会去定义一系列的git规范。在网上现在比较流行的则是Git Flow工作流。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>博主在使用 <code>Git Flow</code> 的过程中发现，不是所有的团队都适用于 <code>Git Flow</code> 这个规范。</p><p>比如你的项目组成员在10人以下，这个时候因为项目组规模较小，使用 <code>Git Flow</code> 工作流往往会增加不必要的操作，从而导致时间成本的增加。</p><p>例如博主本人所管理的项目组是根据 <code>Git Flow</code> 做了一些删减，保留必要的发布流程以外，针对功能的开发并没有使用更多的分支去规范化的管理。而且在这个删减的规范中，还能使用 <code>rebase</code> 去美化我们的分支。</p><p>但如果您所管理的团队人数较多，那您一定要试试 <code>Git FLow</code> 工作流的规范了。</p><h2 id="工作流模型介绍"><a href="#工作流模型介绍" class="headerlink" title="工作流模型介绍"></a>工作流模型介绍</h2><p><img src="http://qcu6ny56e.bkt.clouddn.com/e850352ac65c10384ddd401e94faf115b27e89b8.png" alt="Git FLow工作流模型图片"></p><p>上图是工作流模型的图片，那么下面博主大致介绍下每个分支的介绍</p><h3 id="分支介绍"><a href="#分支介绍" class="headerlink" title="分支介绍"></a>分支介绍</h3><ul><li><p><strong>Master分支</strong>: 每个项目有且仅有一个 <code>master</code> 分支，作为主分支。主要用来存储正式发布的产品，该分支上的代码要随时处于可部署的状态。master分支只能通过合并其他分支来更新内容，禁止直接在master分支上进行修改.</p></li><li><p><strong>Develop分支</strong>: 该分支是开发分支，允许确实功能模块，但已有的功能模块一定是开发完成的。该分支同样也是只能通过合并其他分支进行内容的更新。</p></li><li><p><strong>Feature分支</strong>: 该分支是功能分支，当要开发新功能或者试验新功能时，从 <code>develop</code> 分支创建一个新的 <code>feature</code> 分支，并在 <code>feature</code> 分支上进行开发。开发完成后，需要将该分支合并到 <code>develop</code> 分支，然后删除该分支。</p></li><li><p><strong>Release分支</strong>: 当 <code>develop</code> 分支上的项目准备发布时，从 <code>develop</code> 分支上创建一个新的 <code>release</code> 分支。新建的 <code>release</code> 分支只能进行质量测试，bug修复，文档生成等任务。不能再添加新的功能。这一系列任务完成后需要将 <code>release</code> 分支合并到 <code>master</code> 分支上，并根据版本号为 <code>master</code> 分支添加tag，然后将 <code>release</code> 分支合并到 <code>develop</code> 分支，最后删除该分支。</p></li><li><p><strong>Hotfix分支</strong>: 当 <code>master</code> 分支中的产品出现需要立即修复的bug时，从 <code>master</code> 分支上创建一个新的 <code>hotfix</code> 分支，并在该分支进行bug修复。修复完成后需要将该分支合并到 <code>master</code> 分支和 <code>develop</code> 分支，并为 <code>master</code>打上新的版本号tag，最后删除该分支。</p></li></ul><p>在使用以上工作流时，有一点要万分注意，如果你是一个开发人员，那么 <code>develop</code> 分支和 <code>master</code> 分支你是没有权限操作的，也就是说你只能操作 <code>feature</code> 分支和 <code>hotfix</code> 分支。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们通常知道这个规范后自己使用git的命令去实现这个规范就好了，但同时我们也可以通过可视化工具来完成以下步骤，比如现在使用比较多的 <code>SourceTree</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工作规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 团队协作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TomCat安装及部署</title>
      <link href="/2020/07/04/2020-07-2020-07-04-tomcat-an-zhuang-ji-bu-shu/"/>
      <url>/2020/07/04/2020-07-2020-07-04-tomcat-an-zhuang-ji-bu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat简介"><a href="#tomcat简介" class="headerlink" title="tomcat简介"></a>tomcat简介</h1><p>   Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p><p>   诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>进入官网复制连接后</p><pre><code>wget url</code></pre><p>然后解压</p><pre><code>unzip apache-tomcat-9.0.0.M22.zip</code></pre><p>然后将解压出来的文件夹移动到/opt下</p><pre><code>mkdir /opt/servermv  apache-tomcat-9.0.0.M22 /opt/server</code></pre><p>这个时候去文件夹下的bin目录，可以看到startup.sh和shutdown.sh，但是用ls -l可以看到都没有执行权限,所以我们得手动赋予执行权限</p><pre><code>chmod +x *.sh   ./startup.sh    </code></pre><blockquote><p>这个时候可能在网络上访问不了tomcat，有可能的原因是因为JAVA_HOME的环境变量并没有配置，需要手动配置一下</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TomCat </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native IOS打包及发布</title>
      <link href="/2020/07/02/2020-07-2020-07-02-react-native-ios-da-bao-ji-fa-bu/"/>
      <url>/2020/07/02/2020-07-2020-07-02-react-native-ios-da-bao-ji-fa-bu/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS打包"><a href="#iOS打包" class="headerlink" title="iOS打包"></a>iOS打包</h1><h2 id="打包命令介绍"><a href="#打包命令介绍" class="headerlink" title="打包命令介绍"></a>打包命令介绍</h2><ul><li>通过<code>React Native</code>的<code>react-native bundle</code>命令来进行打包的。</li></ul><blockquote><p><a href="https://github.com/facebook/react-native/blob/master/local-cli/bundle/bundleCommandLineArgs.js" target="_blank" rel="noopener">react-native bundle的详细命令选项</a>。</p></blockquote><p>其中常用命令选项：</p><p><strong>–entry-file</strong> ,ios或者android入口的js名称，比如index.ios.js<br><strong>–platform</strong> ,平台名称(ios或者android)<br><strong>–dev</strong> ,设置为false的时候将会对JavaScript代码进行优化处理。<br><strong>–bundle-output</strong>, 生成的jsbundle文件的名称，比如release_ios/main.jsbundle<br><strong>–assets-dest</strong> 图片以及其他资源存放的目录,比如release_ios/</p><ul><li>导出<code>js bundle</code>的命令</li></ul><pre><code>react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/</code></pre><ul><li>方便使用，可以把打包命令写到<code>npm script</code>中</li></ul><pre><code>"scripts": {    "start": "node node_modules/react-native/local-cli/cli.js start",    "bundle-ios":"node node_modules/react-native/local-cli/cli.js bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/"  },</code></pre><ul><li>运行命令直接打包:</li></ul><pre><code>npm run bundle-ios</code></pre><h2 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h2><h3 id="第一步：导出js-bundle包和图片资源"><a href="#第一步：导出js-bundle包和图片资源" class="headerlink" title="第一步：导出js bundle包和图片资源"></a>第一步：导出js bundle包和图片资源</h3><ul><li>在React Native项目的<strong>根目录</strong>下执行打包命令：</li></ul><pre><code>react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/</code></pre><p>或者 执行:</p><pre><code>npm run bundle-ios</code></pre><p>通过上述命令，将JS部分的代码和图片资源等打包导出到release_ios目录下.</p><blockquote><p>在执行打包命令之前，先确保在项目的根目录有<code>release_ios</code>文件夹，没有的话创建一个。</p></blockquote><h3 id="第二步：将js-bundle包和图片资源导入到iOS项目中"><a href="#第二步：将js-bundle包和图片资源导入到iOS项目中" class="headerlink" title="第二步：将js bundle包和图片资源导入到iOS项目中"></a>第二步：将js bundle包和图片资源导入到iOS项目中</h3><ul><li><p>这一步需要用到XCode，选择<code>assets文件夹</code>与<code>main.jsbundle文件</code>将其拖拽到XCode的项目导航面板中即可。</p><p>  <strong>必须使用Create folder references的方式添加文件夹.</strong></p></li></ul><ul><li>修改AppDelegate.m文件，添加如下代码：</li></ul><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{  NSURL *jsCodeLocation; //jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index.ios" fallbackResource:nil]; +jsCodeLocation = [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];#endif...  return YES;}</code></pre><p>让xcode使用刚才导入的jsbundle摆脱对本地nodejs服务器的依赖。</p><h3 id="第三步：发布iOS应用"><a href="#第三步：发布iOS应用" class="headerlink" title="第三步：发布iOS应用"></a>第三步：发布iOS应用</h3><p>发布还是比较麻烦的，从创建苹果账号到认证到最后的发布，期间还是有一系列问题需要填的。</p><blockquote><p>参考<br><a href="https://www.jianshu.com/p/ce71b4a8a246" target="_blank" rel="noopener">https://www.jianshu.com/p/ce71b4a8a246</a><br><a href="http://www.cocoachina.com/ios/20170511/19250.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20170511/19250.html</a></p></blockquote><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>在我们应用打包完后面临着测试等环节，我们可以使用蒲公英等平台来帮助测试包的派发与测试。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端技术栈 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> React-Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native IOS打包及发布</title>
      <link href="/2020/07/01/2020-07-2020-07-01-react-native-android-da-bao-ji-fa-bu/"/>
      <url>/2020/07/01/2020-07-2020-07-01-react-native-android-da-bao-ji-fa-bu/</url>
      
        <content type="html"><![CDATA[<h1 id="Android打包"><a href="#Android打包" class="headerlink" title="Android打包"></a>Android打包</h1><h2 id="生成签名密钥"><a href="#生成签名密钥" class="headerlink" title="生成签名密钥"></a>生成签名密钥</h2><ul><li><p>打开终端</p></li><li><p>查看java 根目录路径</p></li></ul><pre><code>/usr/libexec/java_home -V</code></pre><pre><code>Matching Java Virtual Machines (1):    1.8.0_121, x86_64:    "Java SE 8"    /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</code></pre><ul><li>去到java安装的根目录，即输入</li></ul><pre><code>cd /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home</code></pre><ul><li>当前用户没有最高权限，在Library文件夹下不能生成任何文件，可以到当前指定目录下生成文件,比如目录:<code>/Users/hanjin/Desktop/key/android.keystore</code></li></ul><pre><code>keytool -genkey -v -alias android -keyalg RSA -validity 20000 -keystore /Users/hanjin/Desktop/key/android.keystore</code></pre><p><strong><code>Alias</code> 是别名，填写APP名称即可，别的名称也行</strong></p><ul><li>按照提示输入信息</li></ul><h2 id="设置-gradle-变量"><a href="#设置-gradle-变量" class="headerlink" title="设置 gradle 变量"></a>设置 gradle 变量</h2><ul><li><p>把 <code>my-release-key.keystore</code>密钥库文件放到工程中的<code>android/app</code>文件夹下</p></li><li><p>编辑 <code>项目目录/android/gradle.properties</code>,<strong>添加如下的代码（注意把其中的**</strong>替换为相应密码）**</p></li></ul><pre><code>MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=*****</code></pre><blockquote><p><strong>my-release-key.keystore</strong> 为密钥库文件名，在<code>android/app</code>文件夹下。<br><strong>my-key-alias</strong> 为生成秘钥的时候设置的别名。</p></blockquote><h2 id="把签名配置加入到项目的-gradle-配置中"><a href="#把签名配置加入到项目的-gradle-配置中" class="headerlink" title="把签名配置加入到项目的 gradle 配置中"></a>把签名配置加入到项目的 gradle 配置中</h2><p>编辑项目目录下的<code>android/app/build.gradle</code>，添加如下的签名配置</p><pre><code>...android {    ...    defaultConfig { ... }    signingConfigs {        release {            if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) {                storeFile file(MYAPP_RELEASE_STORE_FILE)                storePassword MYAPP_RELEASE_STORE_PASSWORD                keyAlias MYAPP_RELEASE_KEY_ALIAS                keyPassword MYAPP_RELEASE_KEY_PASSWORD            }        }    }    buildTypes {        release {            ...            signingConfig signingConfigs.release        }    }}...</code></pre><h2 id="测试应用的发行版本"><a href="#测试应用的发行版本" class="headerlink" title="测试应用的发行版本"></a>测试应用的发行版本</h2><blockquote><p>注意：在 debug 和 release 版本间来回切换安装时可能会报错签名不匹配，此时需要先卸载前一个版本再尝试安装。</p></blockquote><pre><code>react-native run-android --variant=release</code></pre><h2 id="安卓手动打包js"><a href="#安卓手动打包js" class="headerlink" title="安卓手动打包js"></a>安卓手动打包js</h2><pre><code>react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</code></pre><h2 id="生成发行-APK-包"><a href="#生成发行-APK-包" class="headerlink" title="生成发行 APK 包"></a>生成发行 APK 包</h2><pre><code>$ cd android$ ./gradlew assembleRelease</code></pre><p><code>Gradle</code> 的 <strong>assembleRelease</strong> 参数会把所有用到的 JavaScript 代码都打包到一起，然后内置到 APK 包中。</p><blockquote><p>注意：请确保 gradle.properties 中没有包含_org.gradle.configureondemand=true_，否则会跳过 js 打包的步骤，导致最终生成的 apk 是一个无法运行的空壳。</p></blockquote><p>生成的 APK 文件位于<strong>android/app/build/outputs/apk/app-release.apk</strong>，它已经可以用来发布了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端技术栈 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> React-Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务的特性以及隔离级别</title>
      <link href="/2020/06/24/2020-06-2020-06-24-shi-wu-de-te-xing-yi-ji-ge-chi-ji-bie/"/>
      <url>/2020/06/24/2020-06-2020-06-24-shi-wu-de-te-xing-yi-ji-ge-chi-ji-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="事务的特性以及隔离级别"><a href="#事务的特性以及隔离级别" class="headerlink" title="事务的特性以及隔离级别"></a>事务的特性以及隔离级别</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>个人理解，事务就是一连串的sql语句或者说一个独立的工作单元。如果数据库能成功的对该工作单元中所有的sql语句执行成功那么该工作单元就完成。如果其中任何一个sql语句因为奔溃或者其他原因无法执行，那么所有的语句都不会执行。</p><p>换句话说，宏观来看，事务就是一个整体单位，每个单位包含一条以上的sql语句，一旦事务执行了，就意味着所有sql语句都得成功，否则的话，就不执行。</p><p>在理解事务之后，需要知道事务的目的就是为了<strong>保证数据的正确性和一致性</strong>,那么为此诞生了四个特性ACID。而为了实现这四个特性有需要许多具体的实现，其中就包括为了隔离性而产生的四个隔离级别。这四种隔离级别又产生了三个问题(脏读，不可重复读和幻读)</p><h2 id="四种特性-ACID"><a href="#四种特性-ACID" class="headerlink" title="四种特性(ACID)"></a>四种特性(ACID)</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>意思是说 一个事务应当作为一个不可分割的最小单位，整个事务的操作要么全部执行成功，要么全部不执行，像原子一样不可分割。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>意思是说 事务总是从一个一致性的状态跳到另一个一致性的状态。</p><p>我个人理解为，涉及到的数据范围内是守恒的，也就是数据整体不变，打个比方，A给B转了200块，那么整体的钱数是没有发生变化的，A少了200，B多了200，整体变化是0;</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>通常来说，一个事务的操作对于其他的事务是不可见的，也就是说一般而言事务都是独立的。但是这跟数据库的隔离级别有关</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>事务一旦完成，那么该事务引起的数据变化将永久生效，不会改变（除非被另外一个事务改动）</p><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><h3 id="1-未提交读"><a href="#1-未提交读" class="headerlink" title="1. 未提交读"></a>1. 未提交读</h3><p>在这个隔离级别中，在一个事务执行的操作就算不提交也能被其他事务看到。</p><p>在这个级别中一个事务可能读到其他事务还没提交的脏数据，即可能出现<strong>脏读</strong></p><h3 id="2-提交读"><a href="#2-提交读" class="headerlink" title="2. 提交读"></a>2. 提交读</h3><p>在一个事务提交之后，其他事务才可以看到事务的修改。此隔离级别可能会出现同一个事务执行相同的查询读到不同的数据，即<strong>不可重复读</strong>，在未提交读级别也可能出现不可重复读的情况。</p><h3 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3. 可重复读"></a>3. 可重复读</h3><p>这是MySQL默认的隔离级别，在事务开始的时候会保存此刻的一个快照，然后接下来这个事务的所有数据读取都是从这个快照读，所以不会出现不可重复读的情况，但是还是有可能出现幻读。</p><p>意思是读取的是快照表数据不会变化，但是进行写操作如更新的时候，更新的数量可能和预期的不同。</p><h3 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4. 可串行化"></a>4. 可串行化</h3><p>意思是说，事务要一个一个来，如果在一个事务中进行读操作，那么其他事务在该事务完成前只能进行读操作，如果进行写操作，那么其他事务的操作都进入等待（知道当前事务的提交）。这种级别就可以防范目前出现的脏读、不可重复读，幻读等现象</p><h2 id="在执行不同隔离级别保证隔离性的情况下，产生的几个问题"><a href="#在执行不同隔离级别保证隔离性的情况下，产生的几个问题" class="headerlink" title="在执行不同隔离级别保证隔离性的情况下，产生的几个问题"></a>在执行不同隔离级别保证隔离性的情况下，产生的几个问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>即在当前事务中可能读取到其他事务还未提交的脏数据</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在同一个事务中执行相同的查询语句，可能出现不同的数据，通常发生在未提交读、提交读这两个级别</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务中进行写操作时修改的数量和预期不同</p><p>参考资料:<a href="https://www.cnblogs.com/zhangweicheng/p/12273797.html" target="_blank" rel="noopener">粗谈MySQL事务的特性和隔离级别</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 优化之 Explain 命令</title>
      <link href="/2020/06/20/2020-06-2020-06-20-sql-you-hua-zhi-explain-ming-ling/"/>
      <url>/2020/06/20/2020-06-2020-06-20-sql-you-hua-zhi-explain-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-优化之-Explain-命令"><a href="#SQL-优化之-Explain-命令" class="headerlink" title="SQL 优化之 Explain 命令"></a>SQL 优化之 Explain 命令</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在SQL优化的时候我们都会使用Explain命令去查看该条SQL的执行计划信息。</p><p>使用 Explain 关键字可以模拟优化器执行SQL语句，分析查询语句或是结构的性能瓶颈。在select语句之前增加Explain关键字，MySQL会在查询上设置一个标记，执行查询会返回执行计划的信息。因此我们可以根据这个信息去判断该条SQL是否按照我们的预期执行，他的效率和性能是不是良好的</p><h2 id="Explain-信息结构详解"><a href="#Explain-信息结构详解" class="headerlink" title="Explain 信息结构详解"></a>Explain 信息结构详解</h2><p>执行Explain命令后会返回如下信息:</p><p><img src="https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190824115601131-1871572364.jpg" alt="Image Text"></p><p>根据上面的信息，我们讲解下各列的作用。</p><h3 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h3><p>id列的编号是select的序列号，有几个select就有几个id，并且id的顺序是按select出现的顺序增长的。id越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</p><blockquote><p>出现多个id的情况通常适用于关联子查询，即查询的表是select查询后的虚拟表(临时表)</p></blockquote><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>他表示对应行是简单还是复杂的查询,有以下几个值</p><ul><li><strong>simple</strong>: 简单查询。查询不包含子查询和union</li><li><strong>primary</strong>: 查询中若包含任何复杂的子查询，最外层查询则标记为primary，也就是最后加载的那个select</li><li><strong>subquery</strong>:包含在select或者where子句中的子查询(不在from子句中)</li><li><strong>derived</strong>: 包含在from子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表<blockquote><p>derived只会在子查询作为临时表时出现</p></blockquote></li><li><strong>union</strong>:在union关键字随后的select</li></ul><p>该列的例子sql语句</p><pre><code>explain select (select 1 from actor where id = 1) from (select * from filmwhere id = 1) der;explain select 1 union all select 1;</code></pre><h3 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h3><p>这一列标识Explain的一行正在访问哪个表</p><p>当from子句中有子查询时，table列是格式,表示当前依赖id=N的查询，于是先执行id=N的查询。</p><p>当有union时，union result 的table列的值为 <code>&lt;union 1,2&gt;</code> 1和2标识参与union的select行id值</p><h3 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行对应的大概范围。</p><p>依次从最优到最差分别为: <strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; All</strong></p><p>一般来说，除了All都会使用到索引，得保证查询能达到range级别，最好是ref。</p><p>NULL: MySQL能够在优化阶段分解查询语句，在执行阶段用不着访问表或者索引。例如：在索引列中取最小值，可以单独查询索引来完成，不需要执行时访问表。</p><p>下面依次说下各值的含义:</p><ul><li><strong>const 、 system</strong>: mysql能对查询的某部分进行优化并将其转换成一个常量(可以看做是show warnings的结果)。 用于primary key或者unique key的所有列与常数比较时，所以表最多有一个匹配行，读取依次，读速较快。system是const的特例，表中只有一行元素匹配时为system。</li><li><strong>eq_ref</strong>: primary key或者unique key索引的所有部分被连接使用，最多返回一条符合条件的记录。这可能是const之外最好的联接类型，简单的select查询不会出现这种type。</li><li><strong>ref</strong>: 相比eq_ref，不适用唯一索引(unique key)，而是使用普通索引或者唯一索引的部分前缀，索引要和某个值比较，可能会找到多个符合条件的行</li><li><strong>range</strong>: 范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中。使用一个索引来检索给定范围的行</li><li><strong>index</strong>:扫描全表索引，通常比ALl快一些</li><li><strong>All</strong>:全表扫描，意味着MySQL需要从头到尾去查找所有行。这种情况下需要增加索引来进行优化。</li></ul><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h3><p>这一列显示select可能会使用那些查询来查找(通常展示会用到的所有索引名称，以,连接)</p><h3 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h3><p>这一列显示MySQL实际采用哪个索引对该表的访问。</p><p>如果没有使用索引，则该列为NULL。</p><h3 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h3><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以估算出具体使用了索引中的那些列</p><blockquote><p>例如复合索引中，没有使用全部字段，只使用了部分，可以通过该列推断出具体情况</p></blockquote><p>计算规则:</p><ol><li>字符串<ul><li>char(n):n字节长度</li><li>varchar(n):n字节存储字符串长度,如果是ntf-8，则长度为3n+2</li></ul></li><li>数值类型:<ul><li>tinyint:1字节</li><li>smallint:2字节</li><li>int:4字节</li><li>bigint:8字节</li></ul></li><li>时间类型<ul><li>date:3字节</li><li>timestamp:4字节</li><li>datetime:8字节</li></ul></li></ol><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有: const(常量)，字段名等。一般是查询条件或关联条件中等号右边的值，如果是常量，那么ref列是const，非常量的话就是字段名</p><h3 id="row列"><a href="#row列" class="headerlink" title="row列"></a>row列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集的行数。</p><h3 id="filtered列"><a href="#filtered列" class="headerlink" title="filtered列"></a>filtered列</h3><p>5.7版本后默认出现这个列，标识存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量比例(是百分比不是具体记录数)。</p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>这一列是额外信息。</p><ul><li>Using index： 使用覆盖索引(结果集的字段是索引，即select后的字段是film_id)</li><li>Using index condition: 查询的列不完全被索引覆盖，where条件是一个前导的范围</li><li>Using where:使用where语句来处理结果，查询的列未被索引覆盖</li><li>Using temporary: mysql需要创建一张临时表来处理查询。出现这种情况一般要进行优化，首先就是索引优化</li></ul><p>参考资料:<a href="https://www.cnblogs.com/xiaoqiang-code/p/11404149.html" target="_blank" rel="noopener">Mysql Explain详解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis五种数据类型以及其应用场景</title>
      <link href="/2020/06/16/2020-06-2020-06-16-redis-wu-chong-shu-ju-lei-xing-yi-ji-qi-ying-yong-chang-jing/"/>
      <url>/2020/06/16/2020-06-2020-06-16-redis-wu-chong-shu-ju-lei-xing-yi-ji-qi-ying-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis五种数据类型以及其应用场景"><a href="#Redis五种数据类型以及其应用场景" class="headerlink" title="Redis五种数据类型以及其应用场景"></a>Redis五种数据类型以及其应用场景</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Redis是nosql数据库中的一种，也是目前市面上广泛被使用的数据库之一，因为Redis也是内存型数据库，数据存储在内存里，因此它的IO非常之高，我们也常常利用他做缓存的设计来解决并发的问题。</p><p>在使用Redis进行缓存设计时，很有必要了解下它支持的五种数据类型以及其应用场景。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型(string)"></a>字符串类型(string)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>简单的key-value类型，value可以为字符串和数字,实际存储时按照字符串类型存储</li><li>Redis中的字符串是一个字节序列。Redis中一个字符串最多能存储高达512MB的内容</li></ol><h4 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h4><ol><li><code>set key value</code> 设置key对应的值</li><li><code>get key</code>       获取key的值</li><li><code>incr key 1</code>    自增操作，1为可设置的值，代表自增的值</li><li><code>decrby key 1</code>  自减操作，1为可设置的值，代表自减的值</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>常规的key-value缓存应用。常规计数：微博数，粉丝数，点赞数，访问量，库存数量等</li></ol><h3 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型(hash)"></a>哈希类型(hash)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol><li>是一个string类型的field和value的映射表，hash特别适合用于存储对象</li></ol><h4 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h4><ol><li><code>hmset key field1 value1 field2 value2</code> 设置hash某对象的字段及其映射的值</li><li><code>hset key field value</code> 设置单个字段的值</li><li><code>hgetall key</code> 获取key对象的所有field及其映射的值</li><li><code>hget key field</code> 获取key对象指定field的value</li><li><code>hvals key</code> 获取hash中所有的值</li><li><code>hdel key field</code> 删除指定field</li><li><code>hexists key field</code> 判断指定field是否存在</li><li><code>hkeys key</code> 获取hash表对应所有field</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>存储部分可能需要变更的数据,比如用户信息、文章信息。这部分通过redis做个缓存。</li></ol><h3 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型(list)"></a>列表类型(list)</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ol><li>有序可重复列表</li><li>列表本质是是双向链表，可以通过Push或者Pop操作从头部或者尾部增加或删除元素，按照一定的策略可以当做栈或者队列使用</li></ol><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li><code>llen key</code> 获取列表的长度</li><li><code>lpop key</code> 移除并获取列表的第一个元素</li><li>‘lpush key value1 value2…’ 将一个值或多个值插入到列表头部</li><li><code>lrange key start stop</code> 获取列表指定范围内的元素</li><li><code>rpop key</code> 移除列表最后一个元素，并返回其值</li><li><code>rpush key value1 value2</code> 在列表尾部添加一个或多个值</li><li><code>lindex key index</code> 通过索引获取列表指定元素</li></ol><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>关注列表,粉丝列表等可以使用列表实现。</li><li>Redis列表也通常用于消息队列的服务，假如一个应用程序正在执行lpush操作向列表中添加新的元素，我们将这个程序称为“生产者”，与之对应的另外一个程序执行rpop从列表中取出元素，我们称之为“消费者”</li></ol><h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ol><li>无序不可重复列表</li><li>集合成员是唯一的，意味着集合中不能出现重复的数据</li><li>可以使用集合的交并差等方法进行集合间的计算</li><li>集合是通过哈希表实现的，所以添加、删除、查找的时间复杂度都是O(1)</li></ol><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li><code>sadd key value</code> 插入数据</li><li><code>smembers key</code> 获取集合的数据</li><li><code>scard key</code> 获取集合的成员数</li><li><code>sdiff key1 key2</code> 返回给定所有集合的差集</li><li><code>sinter key1 key2</code> 返回给定所有集合的交集</li><li><code>sunion key1 key2</code> 返回给定所有集合的并集</li></ol><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>存储并计算关系(例如关注人，粉丝等数据通过交集可实现共同关注，共同喜好等功能)</li><li>利用唯一性，可以对数据进行去重</li></ol><h3 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合(sorted set)"></a>有序集合(sorted set)</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><ol><li>每个元素带有分值的集合</li><li>虽然成员是唯一的，但是分值可以重复</li></ol><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li><code>zadd key score1 value1</code> 向有序集合添加一个或多个成员，或者更新已存在成员分数</li><li><code>zcard key</code> 获取有序集合的成员数</li><li><code>zrange key start end</code> 通过索引区间返回有序集合指定区间内的成员</li></ol><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li>可应用到排行榜中，再利用分数进行排序，然后可以通过方法获取top10等</li><li>如果需要一个有序不重复的集合列表，可以使用，例如将文章发表的时间作为分数，可以实现文章发布时间线等功能</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>在设置key的时候需要注意命名空间的规范，以<code>:</code>为间隔符，按照项目:模块:id等格式设置key，这样可以在团队协作中起很大作用</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 多列字段索引 最左匹配原则理解</title>
      <link href="/2020/06/15/2020-06-2020-06-15-mysql-duo-lie-zi-duan-suo-yin-zui-zuo-pi-pei-yuan-ze-li-jie/"/>
      <url>/2020/06/15/2020-06-2020-06-15-mysql-duo-lie-zi-duan-suo-yin-zui-zuo-pi-pei-yuan-ze-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-多列字段索引-最左匹配原则理解"><a href="#Mysql-多列字段索引-最左匹配原则理解" class="headerlink" title="Mysql 多列字段索引 最左匹配原则理解"></a>Mysql 多列字段索引 最左匹配原则理解</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在理解Mysql 索引的时候，有看到一篇关于 最左匹配原则的博客，感觉写的挺有意思的，因此做下记录</p><h2 id="多列字段索引他数据结构是什么样的"><a href="#多列字段索引他数据结构是什么样的" class="headerlink" title="多列字段索引他数据结构是什么样的?"></a>多列字段索引他数据结构是什么样的?</h2><p>索引的底层数据就是一颗BTree，那么联合索引（多列字段索引）也是一颗BTree，只不过联合索引的键值数量不是一个而是多个。构建一颗BTree只能根据一个值来构建，因此数据库依据联合索引最左的字段构建BTree。</p><p><img src="https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70" alt="联合索引图"></p><p>我们可以看到最左列，a的值是有顺序的，而b的值是没有顺序的。所以b=2这种查询条件没办法利用索引，因为联合索引首先按照a排序的，b是无序的。</p><p>同时我们还发现在a值相等的情况下，b值又是按照顺序排序的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。打个比方: <code>a=1 and b=2</code>中a，b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而<code>a&gt;1 and b=2</code>中a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p><h2 id="最左匹配原则是什么？"><a href="#最左匹配原则是什么？" class="headerlink" title="最左匹配原则是什么？"></a>最左匹配原则是什么？</h2><p><strong>最左匹配原则</strong>: 最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&lt;,&gt;,between,like）就会停止匹配。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假如建立联合索引(a,b,c)</p><ul><li><strong>全值匹配查询时</strong></li></ul><pre><code>select * from table_name where a = '1' and b = '2' and c = '3' select * from table_name where b = '2' and a = '1' and c = '3' select * from table_name where c = '3' and b = '2' and a = '1' .........</code></pre><p>上面的sql用到了索引。</p><p>where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序。</p><ul><li><strong>匹配左边的列时</strong></li></ul><pre><code>select * from table_name where a = '1' select * from table_name where a = '1' and b = '2'  select * from table_name where a = '1' and b = '2' and c = '3'</code></pre><p>都是从最左边开始连续匹配的，都用到了索引</p><pre><code>select * from table_name where  b = '2' select * from table_name where  c = '3'select * from table_name where  b = '1' and c = '3' </code></pre><p>这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描.</p><pre><code>select * from table_name where a = '1' and c = '3' </code></pre><p>如果不连续时，只用到了a列的索引，b,c列索引都没用到</p><ul><li><strong>匹配列前缀</strong></li></ul><p>如果列时字符型的话，它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符想通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，以此类推比较字符串</p><p>如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p><pre><code>select * from table_name where a like 'As%'; //前缀都是排好序的，走索引查询select * from table_name where  a like '%As'//全表查询select * from table_name where  a like '%As%'//全表查询</code></pre><ul><li><strong>匹配范围值</strong></li></ul><pre><code>select * from table_name where  a &gt; 1 and a &lt; 3</code></pre><p>可以对最左边的列进行范围查询</p><pre><code>select * from table_name where  a &gt; 1 and a &lt; 3 and b &gt; 1;</code></pre><p>多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用索引，也就是只有a用到索引，在1&lt;a&lt;3范围内b是无序的，不能使用索引,找到1&lt;a&lt;3的记录后，只能根据条件b&gt;1继续逐条过滤</p><ul><li><strong>精确匹配某一列并范围匹配另外一列</strong></li></ul><p>如果左边的列时精确查找的，右边的列可以进行范围查找</p><pre><code>select * from table_name where  a = 1 and b &gt; 3;</code></pre><p>a=1的情况下b是有序的，进行范围查找时走的是联合索引</p><ul><li><strong>排序</strong></li></ul><p>一版情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序,归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能再内存中进行排序的话，还能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。MYSQL中把这种在内存中或者磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果order子句用到了索引，就有可能省去文件排序的步骤</p><pre><code>select * from table_name order by a,b,c limit 10;</code></pre><p>因为BTree本身就按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引不包含的列就好了</p><p>order by的子句后面的顺序也必须按照索引列的顺序给出，比如：</p><pre><code>select * from table_name order by b,c,a limit 10;</code></pre><p>这种顺序颠倒的没用到索引</p><pre><code>select * from table_name order by a limit 10;select * from table_name order by a,b limit 10;</code></pre><p>这种用到部分索引</p><pre><code>select * from table_name where a =1 order by b,c limit 10;</code></pre><p>联合索引左边列为常量，后边的列排序可以用到索引</p><p>参考资料:<a href="https://blog.csdn.net/sinat_41917109/article/details/88944290" target="_blank" rel="noopener">Mysql最左匹配原则</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 索引方法 BTree 和 Hash</title>
      <link href="/2020/06/14/2020-06-2020-06-14-mysql-suo-yin-fang-fa-btree-he-hash/"/>
      <url>/2020/06/14/2020-06-2020-06-14-mysql-suo-yin-fang-fa-btree-he-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-索引方法-BTree-和-Hash"><a href="#Mysql-索引方法-BTree-和-Hash" class="headerlink" title="Mysql 索引方法 BTree 和 Hash"></a>Mysql 索引方法 BTree 和 Hash</h1><h2 id="BTree-和-Hash-在-MySQL-里是什么"><a href="#BTree-和-Hash-在-MySQL-里是什么" class="headerlink" title="BTree 和 Hash 在 MySQL 里是什么"></a>BTree 和 Hash 在 MySQL 里是什么</h2><p>在 MySQL 里的 BTree 和 Hash 指的是数据在存储时所使用的数据结构。</p><p>主流的关系型数据库都是使用BTree作为表默认的索引数据结构</p><h3 id="什么是BTree"><a href="#什么是BTree" class="headerlink" title="什么是BTree"></a>什么是BTree</h3><p>BTree 也就是平衡树;</p><p>BTree有以下特点:</p><ol><li>所有非叶子节点只存储键值信息。</li><li>所有叶子节点之间有一个链指针</li><li>数据记录都在叶子节点中</li></ol><p><img src="https://img-blog.csdn.net/20160202205105560" alt="Image Text"></p><p>通常在 BTree 上有两种头指针，一个指向根节点，一个指向关键字最小的叶子节点，而且所有叶子节点之间通过链指针连接起来形成一个链式环结构。</p><p>因此可以对BTree进行两种查询：</p><ol><li>对于主键范围查找</li><li>从根节点开始进行查找</li></ol><p>参考资料:<a href="https://blog.csdn.net/hao65103940/article/details/89032538" target="_blank" rel="noopener">BTree和B+Tree详解</a></p><h3 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h3><p>哈希表，是根据关键码值(Key Value)而直接进行访问的数据结构。 也就是说他通过把关键码值映射到一个位置来访问记录,以加快查找速度。这个映射函数叫做散列函数,这个映射表也叫做散列表。</p><p>那么Hash索引就是采用一定的哈希算法，把键值转换成新的哈希值，检索时不需要类似BTree那样从根节点到叶子节点逐级查找，只需要一次哈希算法即可定位到相应的位置，速度非常快</p><p>怎么通过hash去查找呢</p><p>理想情况下使用Hash函数将被查找的键转为数组的索引。最后根据数组的索引直接取到数据的内存地址。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvOTk5NDEvMjAxNjA3Lzk5OTQxLTIwMTYwNzA2MTYyMzU5ODc0LTExMzI3NzMyMTIuanBn?x-oss-process=image/format,png" alt="Image Text"></p><p>参考资料:<a href="https://blog.csdn.net/bocai_xiaodaidai/article/details/101672832" target="_blank" rel="noopener">哈希表、哈希索引详解</a></p><h2 id="BTree和Hash的区别是什么呢"><a href="#BTree和Hash的区别是什么呢" class="headerlink" title="BTree和Hash的区别是什么呢"></a>BTree和Hash的区别是什么呢</h2><ul><li><strong>如果是等值查询，那么Hash索引有着明显的优势</strong>，在键值唯一的情况下，Hash索引只需要一次算法就能找到对应的值，而BTree需要从根节点逐级往叶子节点搜索。</li><li><strong>如果是范围查询的话，BTree就有明显优势</strong>,就算是有序的键值通过Hash后都可能变成不连续的，因此Hash索引在范围查询上毫无优势。</li><li><strong>Hash无法完成排序以及like “xx%”这样的模糊查询(这个其实也是范围查询)</strong></li><li><strong>Hash索引不支持符合索引的最左匹配原则</strong></li><li><strong>在有大量键值重复的情况，Hash索引的效率也是非常低的</strong></li></ul><h2 id="MySQL各表引擎支持哪些索引呢"><a href="#MySQL各表引擎支持哪些索引呢" class="headerlink" title="MySQL各表引擎支持哪些索引呢"></a>MySQL各表引擎支持哪些索引呢</h2><ul><li><strong>MyISAM</strong>:BTree</li><li><strong>InnoDB</strong>:BTree</li><li><strong>Memory/Heap</strong>:Hash,BTree</li></ul><p>参考资料:<a href="https://www.cnblogs.com/baizhanshi/p/9869782.html" target="_blank" rel="noopener">mysql 存储引擎对索引的支持</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL BTree深入了解</title>
      <link href="/2020/06/13/2020-06-2020-06-13-mysql-btree-shen-ru-liao-jie/"/>
      <url>/2020/06/13/2020-06-2020-06-13-mysql-btree-shen-ru-liao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-BTree深入了解"><a href="#Mysql-BTree深入了解" class="headerlink" title="Mysql BTree深入了解"></a>Mysql BTree深入了解</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在了解完数据库的BTree后，在看某篇博客的时候被里面的几个问题吸引了，博客里也有问题的解答，感觉挺有意思的，因此做下记录以及自己个人的理解</p><p>参考资料:<a href="https://www.cnblogs.com/guangxiang/p/11547039.html" target="_blank" rel="noopener">数据库索引类型及其原理</a></p><h2 id="数据表为什么会使用主键"><a href="#数据表为什么会使用主键" class="headerlink" title="数据表为什么会使用主键?"></a>数据表为什么会使用主键?</h2><p>事实上在Mysql中每个表都会有主键，如果你不设置，则会有隐藏的自增主键Rowid，那么主键的作用是为了让表生成聚集索引,该索引以BTree的结构存放</p><h3 id="那么什么是聚集索引呢"><a href="#那么什么是聚集索引呢" class="headerlink" title="那么什么是聚集索引呢?"></a>那么什么是聚集索引呢?</h3><p>其实就是正常的BTree结构，而他的叶子节点存放的都是实际的data。</p><p>有了聚集索引也会有非聚集索引,那非聚集索引则是叶子节点存放的不是data而是指向对应data的指针。而非聚集索引通常是由一版索引、唯一索引、全文索引创建的</p><p>非聚集索引有以下特点:</p><ol><li>一个表可以有多个非聚集索引(最多249个)</li><li>非聚集索引必须在聚集索引创建之后创建</li><li>在叶子节点存储的是指向对应data的指针</li></ol><h2 id="为什么使用索引后查询效率会变快"><a href="#为什么使用索引后查询效率会变快" class="headerlink" title="为什么使用索引后查询效率会变快?"></a>为什么使用索引后查询效率会变快?</h2><p>假如我们表有100w条数据,如果不使用索引的话，需要全表扫描，会检索100w次，那么就会花费大量时间。</p><p>如果使用索引，打个比方，<code>select id from table_name where id = 234；</code>这个sql会使用主键索引,在根节点上会判断234在那个区间里，然后持续深入去查找，直到对应数据，那么这个查找的次数等于BTree的深度,因此他查找的次数可能就几次，那么所花费的时间当然就少了。因此利用索引在查询的效率上有质的提升</p><h2 id="使用索引后会使插入、修改、删除变慢"><a href="#使用索引后会使插入、修改、删除变慢" class="headerlink" title="使用索引后会使插入、修改、删除变慢?"></a>使用索引后会使插入、修改、删除变慢?</h2><p>每使用一个索引，都会将数据整体复制一遍形成非聚集索引而存储下来，每次删除，修改，新增的时候都需要对所有索引结构进行梳理来确保他的正确性，者会带来不小的开销，这也是变慢的原因</p><h2 id="什么时候需要在两个字段上加索引？"><a href="#什么时候需要在两个字段上加索引？" class="headerlink" title="什么时候需要在两个字段上加索引？"></a>什么时候需要在两个字段上加索引？</h2><p>首先，给表中多个字段加上索引，那么就会出现多个独立的索引结构，每个索引互相之间不存在关联.</p><p>每次给字段建立新索引时，字段中的数据就会被复制一份出来，用于生成索引。因此，给表添加索引，会增加表的体积，占用磁盘存储空间。</p><p>非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键值通过聚集索引查到需要的数据。</p><p>因此不管以何种方式查询表，最终都会利用主键通过聚集索引来定位数据，也就是说<strong>聚集索引(主键)是通往真实数据所在的唯一路径</strong></p><p>但有一种列外不需要使用聚集索引就能查询出所需要的数据，这种称为【覆盖索引】查询，也就是所说的复合索引或者多列字段索引查询。</p><p>如果一个索引指定两个字段，那么这两个数字段的内容都会被同步至索引之中。</p><p>因此在查询时找到对应的非聚集索引里的叶节点内容会出现两个字段的值，因此通过这种方式查找，可以省略后面的两个步骤(找到对应数据的主键、通过主键查询聚集索引中的数据),大大的提高了查询性能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引失效的场景以及原因</title>
      <link href="/2020/06/10/2020-06-2020-06-10-suo-yin-shi-xiao-de-chang-jing-yi-ji-yuan-yin/"/>
      <url>/2020/06/10/2020-06-2020-06-10-suo-yin-shi-xiao-de-chang-jing-yi-ji-yuan-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="索引失效的场景以及原因"><a href="#索引失效的场景以及原因" class="headerlink" title="索引失效的场景以及原因"></a>索引失效的场景以及原因</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常sql优化的过程中，往往会发现一些索引失效的问题，例如预期中该sql应该使用索引，但使用Explain命令后发现并未使用，因此做下记录，记录下索引失效的场景以及原因</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="数据量小的时候，索引可能会失效"><a href="#数据量小的时候，索引可能会失效" class="headerlink" title="数据量小的时候，索引可能会失效"></a>数据量小的时候，索引可能会失效</h3><p>在数据量小的时候，如果MySQL优化器觉得使用索引耗费的时间比全表扫描慢，就会不使用索引而走全表扫描，此时索引失效了。</p><h3 id="在复合索引的情况下，不满足最左匹配原则，索引会失效"><a href="#在复合索引的情况下，不满足最左匹配原则，索引会失效" class="headerlink" title="在复合索引的情况下，不满足最左匹配原则，索引会失效"></a>在复合索引的情况下，不满足最左匹配原则，索引会失效</h3><p>复合索引的情况下，非聚集索引的结构是以最左字段为基础构建的，因此在不满足最左匹配的原则下，mysql不会去使用该索引而会使用全表扫描的方式查找，此时索引失效了</p><h3 id="在复合索引的情况下，满足最左匹配原则，但是使用了范围匹配，会导致索引部分失效"><a href="#在复合索引的情况下，满足最左匹配原则，但是使用了范围匹配，会导致索引部分失效" class="headerlink" title="在复合索引的情况下，满足最左匹配原则，但是使用了范围匹配，会导致索引部分失效"></a>在复合索引的情况下，满足最左匹配原则，但是使用了范围匹配，会导致索引部分失效</h3><p>例如创建了index(a,b,c)复合索引，如果在满足最左匹配的情况下，使用该where子句 <code>where a = 1 and b&gt;3 and c = 2</code>,该情况下，a,b字段都使用了索引，但是c并未使用索引，因为复合索引是基于a字段构建的(a,b,c)为每个节点记录的值，该值在a相等的情况下,b是有序的,因此在b使用范围查询时还是查询的索引，但是之后的C就是无序的了，因此索引会失效,这也是为什么在复合索引创建时，我们要把范围匹配的字段往后放的原因</p><h3 id="对索引使用内置函数-索引会失效"><a href="#对索引使用内置函数-索引会失效" class="headerlink" title="对索引使用内置函数,索引会失效"></a>对索引使用内置函数,索引会失效</h3><p>在对索引使用内置函数后，会导致mysql不会使用索引，因为索引是基于函数处理前的值构建。</p><h3 id="在使用like的时候，索引可能会失效"><a href="#在使用like的时候，索引可能会失效" class="headerlink" title="在使用like的时候，索引可能会失效"></a>在使用like的时候，索引可能会失效</h3><p>字符串类型的字段构建索引时也是类似的顺序，以第一个字符开始构建,类似复合索引的构建顺序。</p><p>在这种情况下，<code>Like "str%"</code> 是会使用索引的，因为按照前缀去匹配。</p><p>但是 <code>like '%str'</code>这种情况就会导致索引失效</p><h3 id="在使用or时，-索引可能会失效"><a href="#在使用or时，-索引可能会失效" class="headerlink" title="在使用or时， 索引可能会失效"></a>在使用or时， 索引可能会失效</h3><p>出于mysql优化器的优化策略。在使用or的情况下可能导致查询的成本高于一次全表扫描，就会导致索引失效。此时可以针对or使用的所有字段建立索引来优化</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现Postgresql10基于wal日志的数据恢复</title>
      <link href="/2020/05/22/2020-05-2020-05-21-shi-xian-postgresql-ji-yu-wal-ri-zhi-de-shu-ju-hui-fu/"/>
      <url>/2020/05/22/2020-05-2020-05-21-shi-xian-postgresql-ji-yu-wal-ri-zhi-de-shu-ju-hui-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="实现Postgresql10基于wal日志的数据恢复"><a href="#实现Postgresql10基于wal日志的数据恢复" class="headerlink" title="实现Postgresql10基于wal日志的数据恢复"></a>实现Postgresql10基于wal日志的数据恢复</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>之前讲过百度里的一些帖子和资源是比较古老的，在后面的发展一些流程或者函数发生变化，因此在使用过程中会有一些问题。而在之前的业务中有用到基于postgresql的wal日志恢复，但百度上的帖子都是基于postgresql10以下的。而postgresql10则针对内部函数有进行优化，部分函数名发生了改变，因此记录下。</p><h2 id="wal日志"><a href="#wal日志" class="headerlink" title="wal日志"></a>wal日志</h2><p>wal日志就是预写式日志，是日志的标准实现方式，简单而言就是将对数据库的变动记录到日志 中，而后在将具体的新数据刷新到磁盘。PostgreSQL将该日志维护在数据文件夹下的子文件夹pg_xlog中。当数据库崩溃后，可以通过“重放”日志中的“动作”，将数据库恢复。也就是说，只要拥有一个基础备份和完整的日志文件，理论上可以将数据库库恢复到任意基础备份以来的任意时刻点。不仅如此，如果在另一个实例上将这些日志不停的“重放”，那么就拥有了一个完整的在线备份，也就是“复制”。</p><p>pg_xlog下日志文件不会无限制增多，也就是说并不用担心日志的增多使得磁盘空间捉襟见肘。默认每个日志文件为16M大小，即当增长到16M时，就会切换到别的文件，并复用之前的文件 。因此，为了保证有个完整的日志链，必须将写满的文件复制保存到一个特定的文件 夹。对于最后一个还未满16M的日志文件，可以手动触发一次切换。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>修改配置文件开启wal日志</p><pre><code>vim /etc/postgresql/10/main/postgresql.confwal_level = replicaarchive_mode = onarchive_command = ' test ! -f /var/lib/postgresql/archive/%f &amp;&amp; cp %p /var/lib/postgresql/archive/%f'`</code></pre><blockquote><p>archive_command是归档命令</p></blockquote><p>然后创建归档目录</p><pre><code>cd /usr/lib/postgressu postgresmkdir archive</code></pre><blockquote><p>切记，是切换到postgres用户再去创建，因为pgsql是以postgres用户去操控的</p></blockquote><p>然后重启服务</p><pre><code>/usr/lib/postgresql/10/bin/pg_ctl restart -D /var/lib/postgresql/10/main/ -o "-c config_file=/etc/postgresql/10/main/postgresql.conf"</code></pre><p>然后创建数据库，数据表啥的填充数据啥的，<br>接着创建基础备份</p><pre><code>psql -c "SELECT pg_start_backup('base', true)"cd /var/lib/postgresql/10/tar -cvf main.tar mainpsql -c "SELECT pg_stop_backup()"</code></pre><blockquote><p>正常情况下，main文件夹以及wal日志文件夹archive都要备份，因为wal日志会记录你后面的操作</p></blockquote><p>这时候创建几张新表，关闭数据库，模拟数据库宕机，此时，数据库test中应该有3张表，其中1张表在基础备份前，也就是恢复完数据文件即可找回，而另2张表则需恢复相应的日志文件。模拟恢复到testPITR2创建时刻点。</p><blockquote><p>notice:在postgresql10版本开始手动触发归档命令由pg_switch_xlog()变为pg_switch_wal(),<br>最好手动设置下环境变量PGDATA</p></blockquote><p>然后<strong>关闭服务器，删除main文件夹，然后重新解压main.tar</strong></p><p>进入main文件夹，生成recovery.conf文件，该文件生成目录在PGDATA目录里，目录地址可以在postgresql.conf文件里找到</p><pre><code>vim recovery.conf</code></pre><p>写入以下参数</p><pre><code>restore_command = 'cp /var/lib/postgresql/archive/%f %p'recovery_target_time = '2016-01-18 10:02:15'</code></pre><blockquote><p>wal日志可以基于时间点回复，或者事务id，但是事务id查询起来特别麻烦，所以最好基于时间点回复，</p></blockquote><p>可以参考的网站:<a href="https://www.cnblogs.com/cxy486/p/5140262.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxy486/p/5140262.html</a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现PHP和JavaScript的TripleDES加密解密(三)</title>
      <link href="/2020/05/20/2020-05-2020-05-20-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-er/"/>
      <url>/2020/05/20/2020-05-2020-05-20-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="实现PHP和JavaScript的TripleDES加密解密-三"><a href="#实现PHP和JavaScript的TripleDES加密解密-三" class="headerlink" title="实现PHP和JavaScript的TripleDES加密解密(三)"></a>实现PHP和JavaScript的TripleDES加密解密(三)</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这章节讲下在加密过程中遇到的一些坑。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>因为前端页面请求的时候会将一个32位16进制字符串转为 CryptoJs 类库里独有的数据结构 WordArray 去参与加密，因此需要在PHP里实现 WordArray 的相同数据结构</p><p>因为只用到了16进制转 WordArray，所以下面着重讲下该过程。</p><pre class=" language-$xslt"><code class="language-$xslt">//解析16进制字符串parse: function (hexStr) {    // Shortcut    var hexStrLength = hexStr.length;    // Convert    var words = [];    for (var i = 0; i < hexStrLength; i += 2) {        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);    }    return new WordArray.init(words, hexStrLength / 2);}</code></pre><pre class=" language-$xslt"><code class="language-$xslt">//wordarray类构造函数init: function (words, sigBytes) {    words = this.words = words || [];    if (sigBytes != undefined) {        this.sigBytes = sigBytes;    } else {        this.sigBytes = words.length * 4;    }},</code></pre><p>看上面代码会发现解析字符串的过程中会涉及到位运算(包括无符号右移、有符号左移),然后再测试过程中发现，JS的位运算和PHP的不一样，因此需要在PHP去实现和JS效果一致的位运算</p><pre class=" language-$xslt"><code class="language-$xslt">//有符号左移function ll($v, $n){  $t = ($v & 0xFFFFFFFF) << ($n & 0x1F);  return $t & 0x80000000 ? $t | 0xFFFFFFFF00000000 : $t & 0xFFFFFFFF;}//无符号右移function uright($a, $n){    $c = 2147483647 >> ($n - 1);    return $c & ($a >> $n);}</code></pre><p>在实现上面位运算后就能成功在PHP去实现 WordArray 这个数据结构</p><pre class=" language-$xslt"><code class="language-$xslt">//创建WordArrayfunction createWordArray($hexString){    $hexStrLength = strlen($hexString);    $words = [];    for ($i = 0; $i < $hexStrLength; $i += 2) {        $words[uright($i,3)] |= ll(hexdec(substr($hexString,$i, 2)),(24 - ($i % 8) * 4));    }    return [        'words'=>$words,        'sigBytes'=>$hexStrLength/2    ];}</code></pre><p>上面则是将16进制字符串转为 WordArray 数据结构的过程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉在实现PHP进行 TripleDES 的加密解密实现时，更能体会到语言只是工具，不变的是思想。只要思想懂了，不管在哪个语言里都能实现。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对称加密 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现PHP和JavaScript的TripleDES加密解密(二)</title>
      <link href="/2020/05/20/2020-05-2020-05-20-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-san/"/>
      <url>/2020/05/20/2020-05-2020-05-20-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-san/</url>
      
        <content type="html"><![CDATA[<h1 id="实现PHP和JavaScript的TripleDES加密解密-二"><a href="#实现PHP和JavaScript的TripleDES加密解密-二" class="headerlink" title="实现PHP和JavaScript的TripleDES加密解密(二)"></a>实现PHP和JavaScript的TripleDES加密解密(二)</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>接着上一章开始讲，上章讲了TripleDES的大致原理以及在JS中的使用方法。因此这章节讲下PHP里去实现TripleDES。</p><h2 id="PHP-里实现TripleDES加密解密"><a href="#PHP-里实现TripleDES加密解密" class="headerlink" title="PHP 里实现TripleDES加密解密"></a>PHP 里实现TripleDES加密解密</h2><pre class=" language-$xslt"><code class="language-$xslt"> function encryptBodyTP($data,$vk,$iv) {         //Pad for PKCS7     $blockSize = mcrypt_get_block_size('tripledes', 'cbc');     $len = strlen($data);     var_dump($len);     $pad = $blockSize - ($len % $blockSize);     var_dump($pad);     $data .= str_repeat(chr($pad), $pad);     $key = $vk;     //Encrypt data     $encData = mcrypt_encrypt('tripledes', $key, $data, 'cbc',$iv);      return base64_encode($encData); }</code></pre><p>上面的代码实现了在PHP下使用cbc工作模式、PKCS7Padding补位模式的加密算法。 而有一点需要注意的是要实现以上加密是需要下载一个php拓展.</p><p>mcrypt拓展。该拓展下载时会有些注意的地方:</p><ol><li>php version &lt; 7.3（不包括7.3）请下载1.0.1版本</li><li>php version &gt;= 7.3 请下载1.0.2版本</li><li>下载完成后需要手动在php.ini里引入一下，如果你使用的是apache的话还需要在apache2里的php.ini里引入</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>准确来说在PHP里实现TripleDES加密不算特别难，就是百度上的许多资料比较老，因此才会产生一系列问题。当然这个加密的过程中还会有一些因为业务而产生的坑，这块下节再讲。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对称加密 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现PHP和JavaScript的TripleDES加密解密(一)</title>
      <link href="/2020/05/18/2020-05-2020-05-18-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-yi/"/>
      <url>/2020/05/18/2020-05-2020-05-18-shi-xian-php-he-javascript-de-tripledes-jia-mi-jie-mi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="实现PHP和JavaScript的TripleDES加密解密-一"><a href="#实现PHP和JavaScript的TripleDES加密解密-一" class="headerlink" title="实现PHP和JavaScript的TripleDES加密解密(一)"></a>实现PHP和JavaScript的TripleDES加密解密(一)</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>因为第三方PaaS服务商的接口调用是使用TripleDES加密参数的，因此需要在PHP实现与js效果一样的加密和解密，因此在花费了一周的时间解决这个问题后，记录过程，因为内容比较多，大致拆分了三部分。<br>    1. 阐述TripleDES算法原理以及JS中的应用<br>    2. 在PHP中模拟TripleDES加密<br>    3. 业务过程中遇到的一些问题及其解决办法</p><h2 id="什么是TriplesDES"><a href="#什么是TriplesDES" class="headerlink" title="什么是TriplesDES"></a>什么是TriplesDES</h2><p>TriplesDES是对称加密中的一种加密方式,而对称加密，是一种比较传统的加密方式，其加密运算、解密运算使用的是同样的密钥，信息的发送者和信息的接收者在进行信息的传输与处理时，必须共同持有该密码（称为对称密码）。因此，通信双方都必须获得这把钥匙，并保持钥匙的秘密</p><p>TripleDES算法提供的key位数更多，加密可靠性更高。使用24字节的key，初始向量IV也是8字节。而算法都是以8字节为一个块进行加密，一个数据块一个数据块的加密，一个8字节的明文加密后的密文也是8字节。如果明文长度不为8字节的整数倍，添加值为0的字节凑满8字节整数倍。所以加密后的密文长度一定为8字节的整数倍。</p><h2 id="js里的TripleDES是什么样的"><a href="#js里的TripleDES是什么样的" class="headerlink" title="js里的TripleDES是什么样的"></a>js里的TripleDES是什么样的</h2><p>在了解TriplesDES加密算法其实就是对称加密算法中的一种后，JavaScript中有提供类似的加密库也就是cryptoJs。因此我们需要在PHP去实现和cryptoJs加密一样的效果,而我们则主要使用cryptoJs中的TriplesDES加密方式</p><pre><code>var iv = CryptoJs.enc.Hex.parse('0000000000000001');var key = CryptoJs.enc.Utf8.parse(sk.substr(0, 24));var msg = CryptoJs.enc.Utf8.parse(JSON.stringify(bodyDict));var encrypted = CryptoJs.TripleDES.encrypt(msg, key, {  iv: iv,  mode: CryptoJs.mode.CBC,  padding: CryptoJs.pad.Pkcs7}).ciphertext;var based = CryptoJs.enc.Base64.stringify(encrypted).toString()</code></pre><p>上面则是在JS中使用 CryptoJs.TripleDES 加密的整个过程。而加密中会使用一些参数，我接下来讲讲这些参数的意思和原理</p><ul><li><strong>msg</strong>: 这个就是加密中的明文，也就是我们需要加密的数据，在加密之前需要转成字符串才能参与加密。</li></ul><ul><li><strong>key</strong>: 这个则是加密使用的key,因为TripleDES使用的是24位key，因此需要截取24位字串</li></ul><ul><li><p><strong>mode</strong>: 工作模式，这个也就是加密算法中的加密方式了，目前常用两种</p><ul><li><strong>ecb</strong>: 一般先将明文分成等长大小的块，通常为8个字节。然后用相同的密钥对每个明文块加密</li><li><strong>cbc</strong>: 先对当前的明文组和上一个密文组做异或，然后将异或的结果用密钥加密</li></ul></li></ul><ul><li><p><strong>iv</strong>: 初始向量,在cbc模式中主要跟第一组明文组做异或操作后再和密钥加密的，因此也称始向量。</p></li><li><p><strong>padding</strong>: 则是补位模式，因为加密方式的原因，通常会每8个字节拆为一个明文组进行加密。因此会遇到一个问题，如果明文不是8的倍数怎么办？数据补位实际是在数据不满8字节的倍数，才补充到8字节的倍数的填充过程</p><ul><li><p>NoPadding: 算法本身不填充，比如.NET的padding提供了有None，Zeros方式，分别为不填充和填充0的方式。</p></li><li><p>PKCS7Padding（PKCS5Padding）填充方式：为.NET和JAVA的默认填充方式，对加密数据字节长度对8取余为r，如r大于0，则补8-r个字节，字节为8-r的值；如果r等于0，则补8个字节8。</p><blockquote><p>比如：加密字符串为为AAA，则补位为AAA55555;加密字符串为BBBBBB，则补位为BBBBBB22；加密字符串为CCCCCCCC，则补位为CCCCCCCC88888888。 </p></blockquote></li></ul></li></ul><p>因此在了解上面所有参数后，大概就知道这个加密算法的运作方式了，接下来只需要在PHP中去模拟TripleDES加密了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对称加密 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel Passport中使用JSON API形式的code授权模式小结</title>
      <link href="/2020/05/18/2020-05-2020-05-18-laravel-passport-json-api-de-shi-yong-xiao-jie/"/>
      <url>/2020/05/18/2020-05-2020-05-18-laravel-passport-json-api-de-shi-yong-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel-Passport中使用JSON-API形式的code授权模式小结"><a href="#Laravel-Passport中使用JSON-API形式的code授权模式小结" class="headerlink" title="Laravel Passport中使用JSON API形式的code授权模式小结"></a>Laravel Passport中使用JSON API形式的code授权模式小结</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>业务需要开发账号系统，所以在Laravel中使用passport。使用密码授权模式进行前台用户的登录时合格的，但是在开发Oauth的第三方服务的时候，发现授权码模式有一些坑，最后通宵解决了，因此做如下记录</p><h2 id="授权码模式的配置"><a href="#授权码模式的配置" class="headerlink" title="授权码模式的配置"></a>授权码模式的配置</h2><h3 id="1-在config-auth-php文件中，将web的验证驱动修改为passport"><a href="#1-在config-auth-php文件中，将web的验证驱动修改为passport" class="headerlink" title="1.在config/auth.php文件中，将web的验证驱动修改为passport"></a>1.<strong>在<code>config/auth.php</code>文件中，将web的验证驱动修改为passport</strong></h3><p>第一个坑：虽然文档上说可以直接将地址重定向，但是在跳转时还是会有验证，因为之前使用密码授权模式并且使用token。所以驱动改为passport后，授权码模式的相关接口将会使用和账号密码一样的验证方式</p><pre><code>    'guards' =&gt; [            'web' =&gt; [            'driver' =&gt; 'passport',            'provider' =&gt; 'users',        ],</code></pre><h3 id="2-在使用passort驱动后，需要编写一个路由中间件，在Kernel-php文件中在所有请求前使用。"><a href="#2-在使用passort驱动后，需要编写一个路由中间件，在Kernel-php文件中在所有请求前使用。" class="headerlink" title="2.在使用passort驱动后，需要编写一个路由中间件，在Kernel.php文件中在所有请求前使用。"></a>2.<strong>在使用passort驱动后，需要编写一个路由中间件，在Kernel.php文件中在所有请求前使用。</strong></h3><p>因为之前使用的json api的验证方式，token需卸载header里面才能通过验证，但是在页面重定向时无法设置hader头信息。</p><p>因为passport的验证也是通过中间件来进行的，并且他们的读取也是通过Laravel的Request类来读取header信息，因此写一个中间件去读取query string里面的tokn信息并设置到header里面，并放在所有中间件之前运行即可像之前密码授权方式一样通过验证。</p><pre><code>class DealToken{    /**     * Handle an incoming request.     *     * @param  \Illuminate\Http\Request  $request     * @param  \Closure  $next     * @param  string|null  $guard     * @return mixed     */    public function handle($request, Closure $next, $guard = null)    {        $request = app(Request::class);        if ($request-&gt;has('access_token')) {            $request-&gt;headers-&gt;set('Authorization','Bearer '.$request-&gt;get('access_token'));        }        return $next($request);    }} </code></pre><h3 id="3-创建Client模型-设置为passport使用的客户端模型，并重写方法skipsAuthorization恒定返回true来跳过授权确认页面"><a href="#3-创建Client模型-设置为passport使用的客户端模型，并重写方法skipsAuthorization恒定返回true来跳过授权确认页面" class="headerlink" title="3.创建Client模型,设置为passport使用的客户端模型，并重写方法skipsAuthorization恒定返回true来跳过授权确认页面"></a>3.<strong>创建Client模型,设置为passport使用的客户端模型，并重写方法<code>skipsAuthorization</code>恒定返回true来跳过授权确认页面</strong></h3><p>按照文档中的流程，是先重定向到一个页面后点击授权。那么会遇到两个问题</p><ol><li>整个过程会经历两个接口：<code>GET /oauth/authorize</code>和<code>POST /oauth/authorize</code>。但是在这个过程中，上面一步的token在两个接口调用的过程中是不会被传递的。</li><li>不能直接使用<code>POST /oauth/authorize</code>方法，因为passport在第一个接口中会在session中存入authrequest的数据，并且在第二个接口去验证</li></ol><p>因此重写该方法跳过授权页面，在<code>GET /oauth/authorize</code>时不会显示授权页面而是直接执行<code>POST /oauth/authorize</code>并进行跳转</p><p>在<code>AuthServiceProvider</code>设置客户端模型</p><pre><code>Passport::useClientModel(ClientsModel::class);</code></pre><p>创建Client模型，重写<code>skipsAuthorization</code>方法</p><pre><code>&lt;?phpnamespace App\Models\Passport;use Laravel\Passport\Client as BaseClient;class Client extends BaseClient{    /**     * 确定客户端是否应跳过授权提示。     *     * @return bool     */    public function skipsAuthorization()    {        return $this-&gt;firstParty();    }}</code></pre><h3 id="4-最后再开发授权登录页面以及通过code换取token的接口就完成了"><a href="#4-最后再开发授权登录页面以及通过code换取token的接口就完成了" class="headerlink" title="4.最后再开发授权登录页面以及通过code换取token的接口就完成了"></a>4.最后再开发授权登录页面以及通过code换取token的接口就完成了</h3><h2 id="code模式认证流程"><a href="#code模式认证流程" class="headerlink" title="code模式认证流程"></a>code模式认证流程</h2><p>1.重定向到授权登录页面让用户登录</p><p>2.登录成功就重定向到<code>GET /oauth/authorize</code>，除了携带指定参数外，还需使用get方式传递第一步登录获取的token</p><p>3.页面会重定向到Client中的redirect的地址并携带code</p><p>3.第三方会在redirect页面接受code并处理，携带code调用对应接口换取token,该接口也会返回用户唯一标识guid</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前国内的网上有很多文档因为版本的更新或者没关注这个地方，从而导致文档的正确性出现问题，因此遇到和文档不符的时候可以大胆尝试，如解决不了可以去通过google或者stack overflow寻求帮助。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT流程详解</title>
      <link href="/2019/11/18/2019-11-2019-11-18-jwt-liu-cheng-xiang-jie/"/>
      <url>/2019/11/18/2019-11-2019-11-18-jwt-liu-cheng-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT的流程详解"><a href="#JWT的流程详解" class="headerlink" title="JWT的流程详解"></a>JWT的流程详解</h1><h2 id="JWT流程总览"><a href="#JWT流程总览" class="headerlink" title="JWT流程总览"></a>JWT流程总览</h2><ul><li>用户端发送登录请求携带账号以及密码</li></ul><blockquote><p>或者其他登录方式都可以</p></blockquote><ul><li><p>服务端验证并通过请求后开始生成token，并返回到客户端</p></li><li><p>客户端接收到token后需要存在本地，以做后续请求的验证</p></li><li><p>此后的每一次客户端发送的请求都会携带token</p></li><li><p>服务端会在中间件进行拦截，过滤非法的请求</p></li></ul><blockquote><p>token可以设置有效时间，通常情况下最好设置一个有效时间</p></blockquote><ul><li>服务端可以通过token解密出一开始就存储的对象信息</li></ul><p><img src="https://images2018.cnblogs.com/blog/1401949/201806/1401949-20180606164320683-1736251056.png" alt="image"></p><h3 id="服务端验证通过登录请求后生成token"><a href="#服务端验证通过登录请求后生成token" class="headerlink" title="服务端验证通过登录请求后生成token"></a>服务端验证通过登录请求后生成token</h3><p>用户端发送登录请求就不在多说了，直接开始正文部分</p><ol><li>服务端首先会定义token的header头信息，里面包括了加密算法和token的类型</li></ol><pre><code>{  "typ": "JWT",  "alg": "HS256"}</code></pre><ol start="2"><li>然后会在payload(负载)里存入对象数据</li></ol><pre><code>{  "sub": "1234567890",  "name": "John Doe",  "admin": true}</code></pre><blockquote><p>此处负载官网有推荐的信息，除此之外还能添加额外的信息，但是有一点要注意，token的加密方法是对称加密，意味着这些信息可以被解密，所以都是明文</p></blockquote><ol start="3"><li>最后生成签名，利用base64加密后的前部分信息，通过header指定的加密算法，组合秘钥加盐最后生成的</li></ol><pre><code>var encodedString = base64UrlEncode(header) + "." + base64UrlEncode(payload); HMACSHA256(encodedString, 'secret');</code></pre><ol start="4"><li>最后三者通过<code>.</code>连接，然后返回给客户端</li></ol><h3 id="客户端发送请求的时候如何携带token"><a href="#客户端发送请求的时候如何携带token" class="headerlink" title="客户端发送请求的时候如何携带token"></a>客户端发送请求的时候如何携带token</h3><p>客户端接收token后会通过本地缓存的方式存储token</p><p>然后会在之后的每次请求的请求头里面加入Authorization并加上Bearer标注</p><pre><code>fetch('api/user/1', {  headers: {    'Authorization': 'Bearer ' + token  }})</code></pre><h3 id="服务端中间件接收后如何拦截"><a href="#服务端中间件接收后如何拦截" class="headerlink" title="服务端中间件接收后如何拦截"></a>服务端中间件接收后如何拦截</h3><p>首先服务端接收token会将header以及payload再次base64编码，然后按照header指定的加密方式，再次进行加密，然后和签名校验下，如果不同，则说明此次请求有被篡改，因此会被过滤掉，并返回错误信息</p><p>那么只要保证秘钥存放在服务端，不会泄露，那么token基本上是安全的</p><p>本文借鉴于<a href="https://www.cnblogs.com/anny0404/p/5318692.html" target="_blank" rel="noopener">基于jwt的token验证</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发知识帖子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORM模型里的渴求式加载与懒惰式加载</title>
      <link href="/2019/11/01/2019-11-2019-11-01-orm-mo-xing-li-de-ke-qiu-shi-jia-zai-yu-lan-duo-shi-jia-zai/"/>
      <url>/2019/11/01/2019-11-2019-11-01-orm-mo-xing-li-de-ke-qiu-shi-jia-zai-yu-lan-duo-shi-jia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="懒惰式加载"><a href="#懒惰式加载" class="headerlink" title="懒惰式加载"></a>懒惰式加载</h1><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">// 获取 ID 为 10 的帖子</span>    <span class="token variable">$post</span><span class="token operator">=</span>Post<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">findByPk</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取帖子的作者(author): 此处将执行一个关联查询。</span>    <span class="token variable">$author</span><span class="token operator">=</span><span class="token variable">$post</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">author</span><span class="token punctuation">;</span></code></pre><p>用模型的属性的方式加载关联属性数据，则为懒惰式加载，仅当第一次访问关联属性时，才进行查询加载。</p><p>加入一次性要访问的数据比较多，比如一个表格中，若干干行的数据都是此关联属性。那么懒惰式加载将非常影响效率。</p><p>因为每个关联属性，都会单独的去查询一次数据库。</p><blockquote><p>懒惰式加载本质是N+1查询,假设查询25个帖子及其作者的时候，可能就会查询26次数据库,第一次是查询所有帖子，然后25次是查询每个帖子的作者</p><p>大致顺序是先请求数据库获取帖子模型实例，然后再去拿帖子的关联属性去查询作者模型实例,这样的话在关联的数据较大时候会浪费数据库的性能.</p></blockquote><h1 id="渴求式加载"><a href="#渴求式加载" class="headerlink" title="渴求式加载"></a>渴求式加载</h1><pre class=" language-php"><code class="language-php">    <span class="token variable">$posts</span><span class="token operator">=</span>Post<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码将返回一个 Post 实例的数组。与懒惰式加载方式不同，在我们访问每个 Post 实例中的 author 属性之前，它就已经被关联的 User 实例填充了。 渴求式加载通过 一个 关联查询返回所有帖子及其作者，而不是对每个帖子执行一次关联查询。</p><blockquote><p>渴求式加载的顺序大概是，在查询帖子模型实例之后就把作者模型实例给查询出来了，总共就查询了<strong>两次</strong>，后续的关联查询就不会在数据库里查询，因此在关联数据较大的情况下使用渴求式加载节约性能</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的Kubernetes学习笔记</title>
      <link href="/2019/11/01/2019-11-2019-11-01-docker-de-kubernetes-xue-xi-bi-ji/"/>
      <url>/2019/11/01/2019-11-2019-11-01-docker-de-kubernetes-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="kubernetes-简称：k8s"><a href="#kubernetes-简称：k8s" class="headerlink" title="kubernetes(简称：k8s)"></a>kubernetes(简称：k8s)</h2><p>k8s是一个集群编排工具(集群调度程序)</p><h2 id="使用所需要注意的地方"><a href="#使用所需要注意的地方" class="headerlink" title="使用所需要注意的地方"></a>使用所需要注意的地方</h2><ol><li>使用k8s需要连接外网，所以可以使用vpn或者使用大厂的解决工具k8s-for-docker-desktop(github仓库里搜索)</li><li>验证k8s成功则使用<code>kubectl version</code>来查看信息</li><li>目前docker只有windows以及mac版，所以ubuntu这样的环境最好使用minikube(单服务器集群)</li><li>docker的容器是必须以前台形式存活的，一个容器里最好只有一个进程，这样当进程被终止掉后，容器也会被关闭，这样k8s工具可以监听到容器的关闭然后重启他</li></ol><h2 id="k8s的使用"><a href="#k8s的使用" class="headerlink" title="k8s的使用"></a>k8s的使用</h2><ol><li>k8s的使用方式分为两种，命令式以及声明式<ul><li>命令式，顾名思义就是在终端里敲对应的命令，例如<code>kubectl run</code>这样的，但是这样是只适合在本地开发测试使用，在生产环境中最好不要这样使用</li><li>声明式,即使用服务编排文件,文件后缀为.yml,这样利于在不同节点之间服务的统一性，因此在生产环境中最好使用这种方式</li></ul></li><li>k8s的命名规则是不适用驼峰法，单词与单词之间用.或者-连接.</li></ol><h2 id="k8s概念"><a href="#k8s概念" class="headerlink" title="k8s概念"></a>k8s概念</h2><h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>k8s是以pod为最小单位来调度并管理docker容器,其中一个pod可含多个容器，且相同pod里的容器共享本地网络，容器间可通过localhost地址互访，即容器如同部署在相同的主机上，而以pod为最小单元来调度则表明：pod内的容器被调度到相同的docker节点上</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>将应用直接以pod形式部署很少见，主因是：pod无法提供弹性伸缩，且节点故障时k8s无法将其调度到幸存节点上，缺少自愈能力。鉴于此，应用常使用“镜像Rc部署Delopyment”部署，且在k8s新版本中，官方推荐用Deployment替代rc部署无状态应用</p><blockquote><p>执行kubectl delete pod <pod_name>删除Pod后，可发现deployment将自动重建pod，其将确保拥有.spec.replicas个pod数量，即意味着，当pod异常时，deployment具备自愈特性。</pod_name></p></blockquote><blockquote><p>当需伸缩或扩展应用时，若以Pod形式部署，则需删除或创建Pod，而若使用Deployment部署，则我们仅需调整.spec.replicas，而后K8S镜像控制器将自动调整Pod数量</p></blockquote><h2 id="k8s常用命令"><a href="#k8s常用命令" class="headerlink" title="k8s常用命令"></a>k8s常用命令</h2><p>k8s的命令行工具是<code>kubectl</code></p><pre><code>kubectl get pods -o wide|json|yaml      不同格式输出pods信息kubectl get all --all-namespaces        查看所有服务kubectl run db --image redis            创建一个名为db的服务，镜像为rediskubectl delete deployment db            删除dbkubectl exec db [命令,例如ls /etc]       在容器中运行命令kubectl exec -it db sh                  以终端打开容器kubectl create -f pod/a.yml             以pod/a.yml的编排文件创建kubectl describe pod db                 查看服务的详细信息kubectl describe -f pod/a.yml           查看某个服务编排文件的详细信息</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
